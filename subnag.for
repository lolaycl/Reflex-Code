C=======================================================
C============SUBROUTINE DE NAG =========================
C=======================================================



C     ===================================================
C     ======================== D01AHF ===================
C     ===================================================


      DOUBLE PRECISION FUNCTION D01AHF(A,B,EPR,NPTS,RELERR,F,NL,IFAIL)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 8A REVISED. IER-254 (AUG 1980).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 12B REVISED. IER-525 (FEB 1987).
C     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).
C     MARK 14 REVISED. IER-819 (DEC 1989).
C
C     THIS FUNCTION ROUTINE PERFORMS AUTOMATIC INTEGRATION OVER A
C     FINITE INTERVAL USING THE BASIC INTEGRATION ALGORITHMS D01AHY
C     AND D01AHX, TOGETHER WITH, IF NECESSARY, AN ADAPTIVE
C     SUBDIVISION PROCESS.nag
C
C     INPUT ARGUMENTS
C     ----- ----------
C     A,B     -  LOWER AND UPPER INTEGRATION LIMITS.
C     EPR     -  REQUIRED RELATIVE ACCURACY.
C     NL      -  APPROXIMATE LIMIT ON NUMBER OF INTEGRAND
C                EVALUATIONS. IF SET NEGATIVE OR ZERO THE
C                DEFAULT IS 10000.
C     F       -  THE USER NAMED AND PREPARED FUNCTION  F(X)
C                GIVES THE VALUE OF THE INTEGRAND AT X.
C     IFAIL      INTEGER VARIABLE
C             - 0  FOR HARD FAIL REPORT
C             - 1  FOR SOFT FAIL REPORT
C
C     OUTPUT ARGUMENTS
C     ------ ----------
C     NPTS    -  NUMBER OF INTEGRAND EVALUATIONS USED IN OBTAINING
C                THE RESULT.
C     RELERR  -  ROUGH ESTIMATE OF RELATIVE ACCURACY ACHIEVED.
C     IFAIL   -  VALUE INDICATES THE OUTCOME OF THE INTEGRATION -
C                IFAIL  = 0  CONVERGED
C                IFAIL  = 1  INTEGRAND EVALUATIONS EXCEEDED  NL.
C                            THE RESULT WAS OBTAINED BY CONTINUING
C                            BUT IGNORING ANY NEED TO SUBDIVIDE.
C                            RESULT LIKELY TO BE INACCURATE.
C                IFAIL  = 2  DURING THE SUBDIVISION PROCESS
C                            THE STACK BECAME FULL
C                            (PRESENTLY SET TO HOLD 20
C                            LEVELS OF INFORMATION.  MAY BE
C                            INCREASED BY  ALTERING  ISMAX
C                            AND THE DIMENSIONS OF STACK
C                            AND ISTACK). RESULT IS
C                            OBTAINED BY CONTINUING BUT
C                            IGNORING CONVERGENCE FAILURES
C                            ON INTERVALS  WHICH CANNOT BE
C                            ACCOMMODATED ON THE STACKS.
C                            RESULT LIKELY TO BE
C                            INACCURATE.
C                IFAIL  = 3  INVALID ACCURACY REQUEST.
C
C     THE SUBDIVISION STRATEGY IS AS FOLLOWS -
C     AT EACH STAGE AN INTERVAL IS PRESENTED FOR SUBDIVISION
C     (INITIALLY THE WHOLE INTERVAL). THE POINT OF SUBDIVISION IS
C     DETERMINED BY THE RELATIVE GRADIENT OF THE INTEGRAND
C     AT THE END POINTS (SEE D01AHZ) AND MAY BE IN THE
C     RATIO 1/2, 1/1 OR 2/1.D01AHY IS THEN APPLIED TO EACH
C     SUBINTERVAL.  SHOULD IT FAIL TO CONVERGE ON THE LEFT
C     SUBINTERVAL THE SUBINTERVAL IS STACKED FOR FUTURE
C     EXAMINATION AND THE RIGHT SUBINTERVAL IMMEDIATELY
C     EXAMINED. SHOULD  IT FAIL ON THE RIGHT SUBINTERVAL
C     SUBDIVISION IS IMMEDIATELY PERFORMED AND THE WHOLE
C     PROCESS REPEATED. EACH CONVERGED RESULT IS
C     ACCUMULATED AS THE PARTIAL VALUE OF THE INTEGRAL.
C     WHEN THE LEFT  AND RIGHT SUBINTERVALS BOTH CONVERGE
C     THE INTERVAL LAST STACKED IS SUBDIVIDED AND THE
C     PROCESS REPEATED.
C     A NUMBER OF REFINEMENTS ARE INCLUDED.  ATTEMPTS ARE MADE TO
C     DETECT LARGE VARIATIONS IN THE INTEGRAND AND
C     TRANSFORMATIONS ARE MADE IF ENDPOINT VARIATION IS
C     EXTREME. THIS DEPENDS ON THE RATE OF CONVERGENCE OF
C     D01AHX AND ON THE END POINT RELATIVE GRADIENTS OF THE
C     INTEGRAND FOR THE NON-SUBDIVIDED INTERVAL.  RANDOM
C     TRANSFORMATIONS ARE ALSO APPLIED TO IMPROVE THE
C     RELIABILITY.  THE  RELATIVE ACCURACY REQUESTED ON
C     EACH SUBINTERVAL IS ADJUSTED IN ACCORDANCE WITH ITS
C     LIKELY CONTRIBUTION TO THE TOTAL INTEGRAL.
C
C     .. Parameters ..
      CHARACTER*6                      SRNAME
      PARAMETER                        (SRNAME='D01AHF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 A, B, EPR, RELERR
      INTEGER                          IFAIL, NL, NPTS
C     .. Function Arguments ..
      DOUBLE PRECISION                 F
      EXTERNAL                         F
C     .. Scalars in Common ..
      DOUBLE PRECISION                 AFLOW, ALP, AV, CRATE, EPMACH,
     *                                 UFLOW
      INTEGER                          IR, MRULE, NT
C     .. Local Scalars ..
      DOUBLE PRECISION                 QSUBND
      DOUBLE PRECISION                 AMAXL, AMAXR, C2, COMP, EPS,
     *                                 EPSIL, EPSR, FACTOR, SUB1, SUB2,
     *                                 SUB3, TEST, V
      INTEGER                          IC, ICQ, IL, IS, ISI, ISMAX, IT,
     *                                 K, KK, NF, NLIM, NLIMIT, NTMAX
C     .. Local Arrays ..
      DOUBLE PRECISION                 RESULT(8), STACK(120)
      INTEGER                          ISTACK(20)
      CHARACTER*1                      P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION                 D01AHU, D01AHZ, X02AJF, X02AMF
      INTEGER                          P01ABF
      EXTERNAL                         D01AHU, D01AHZ, X02AJF, X02AMF,
     *                                 P01ABF
C     .. External Subroutines ..
      EXTERNAL                         D01AHY
C     .. Intrinsic Functions ..
      INTRINSIC                        ABS, LOG, MAX, MIN, SIGN
C     .. Common blocks ..
      COMMON                           /AD01AH/CRATE, MRULE
      COMMON                           /CD01AH/ALP, AV, NT, IR
      COMMON                           /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Data statements ..
      DATA                             ISMAX, NLIM, NTMAX, TEST/116,
     *                                 10000, 10, 0.25D0/
C     .. Executable Statements ..
      IL = 3
      ICQ = IFAIL
      IF (EPR.LE.0.0D0) GO TO 220
C     EPMACH SHOULD BE SLIGHTLY LARGER THAN THE RELATIVE
C     MACHINE ACCURACY.
      EPMACH = 1.1D0*X02AJF()
C     UFLOW IS THE SMALLEST POSITIVE real*8 NUMBER REPRESENTABLE
C     ON THE MACHINE WHICH CAN BE INVERTED WITHOUT OVERFLOW.
      UFLOW = X02AMF()
      AFLOW = LOG(X02AMF())
      CRATE = 0.0D0
      EPSR = EPR/10.0D0
      NLIMIT = NL
      IF (NLIMIT.LE.0) NLIMIT = NLIM
      EPSIL = MIN(EPSR,1.0D-3)
      CALL D01AHY(A,B,RESULT,K,EPSIL,NPTS,IFAIL,F,AMAXL,AMAXR,A,0)
      D01AHF = RESULT(K)
      RELERR = ABS(RESULT(K)-RESULT(K-1))
      IF (ABS(D01AHF).GT.100.0D0*UFLOW) RELERR = RELERR/D01AHF
      RELERR = MAX(RELERR,0.5D0*EPMACH)
C
C     CHECK IF SUBDIVISION IS NEEDED
      IF (IFAIL.EQ.0) RETURN
C
C     SUBDIVIDE
      EPSIL = EPSIL*0.5D0
      FACTOR = 1.0D0
      NT = 1
      RELERR = 0.0D0
      QSUBND = 0.0D0
      D01AHF = 0.0D0
      IS = 1
      ISI = 1
      IC = 1
      SUB1 = A
      SUB3 = B
   20 IF (ABS(SUB1-SUB3).LT.20.0D0*EPSIL*(ABS(SUB1)+ABS(SUB3))) THEN
	 K = 1
	 RESULT(K) = F((SUB1+SUB3)/2.0D0)*(SUB3-SUB1)
	 COMP = 0.0D0
	 NPTS = NPTS + 1
	 GO TO 160
      END IF
      SUB2 = D01AHZ(SUB1,SUB3,AMAXL,AMAXR)
      EPS = MIN(0.5D-3,FACTOR*EPSIL)
C
C     PROCESS SUBINTERVAL (SUB1,SUB2)
      IT = 0
      IF (AMAXL.GT.TEST .AND. CRATE.LE.21.0D0) IT = 1
      V = AMAXR
      C2 = CRATE
      CALL D01AHY(SUB1,SUB2,RESULT,K,EPS,NF,IFAIL,F,AMAXL,AMAXR,SUB1,IT)
      NPTS = NPTS + NF
      IF (NPTS.LE.NLIMIT) GO TO 40
      IC = SIGN(2,IC)
   40 COMP = ABS(RESULT(K)-RESULT(K-1))
      IF (IFAIL.EQ.0) GO TO 100
      IF (ABS(IC).EQ.2) GO TO 100
      IF (IS.GE.ISMAX) GO TO 80
C
C     STACK SUBINTERVAL (SUB1,SUB2) FOR FUTURE EXAMINATION
      IF (RESULT(K).EQ.0.0D0) RESULT(K) = D01AHF
      STACK(IS) = MAX(1.0D0,ABS(D01AHF/RESULT(K))*0.1D0)
      IS = IS + 1
      STACK(IS) = SUB1
      IS = IS + 1
      STACK(IS) = SUB2
      IS = IS + 1
      STACK(IS) = AMAXL
      IS = IS + 1
      STACK(IS) = AMAXR
      IS = IS + 1
      STACK(IS) = CRATE
      IS = IS + 1
      KK = NT
      IF (IT.EQ.0) GO TO 60
      IF (IFAIL.EQ.4) GO TO 60
      IF (NT.GE.NTMAX) GO TO 60
      KK = NT + 1
   60 ISTACK(ISI) = KK
      ISI = ISI + 1
      GO TO 120
   80 IC = -ABS(IC)
  100 QSUBND = QSUBND + RESULT(K)
      D01AHF = QSUBND
      RELERR = RELERR + COMP
C
C     PROCESS SUBINTERVAL (SUB2,SUB3)
  120 IT = 0
      IF (V.GT.TEST .AND. C2.LE.21.0D0) IT = 1
      CALL D01AHY(SUB2,SUB3,RESULT,K,EPS,NF,IFAIL,F,AMAXL,AMAXR,SUB3,IT)
      NPTS = NPTS + NF
      IF (NPTS.LE.NLIMIT) GO TO 140
      IC = SIGN(2,IC)
  140 COMP = ABS(RESULT(K)-RESULT(K-1))
      IF (IFAIL.EQ.0) GO TO 160
      IF (ABS(IC).EQ.2) GO TO 160
C
C     SUBDIVIDE INTERVAL (SUB2,SUB3)
      IF (IT.EQ.1 .AND. IFAIL.NE.4) NT = NT + 1
      SUB1 = SUB2
      IF (RESULT(K).EQ.0.0D0) RESULT(K) = D01AHF
      FACTOR = MAX(1.0D0,ABS(D01AHF/RESULT(K))*0.1D0)
      GO TO 20
  160 QSUBND = QSUBND + RESULT(K)
      D01AHF = QSUBND
      RELERR = RELERR + COMP
      IF (IS.EQ.1) GO TO 180
C
C     SUBDIVIDE THE DELINQUENT INTERVAL LAST STACKED
      ISI = ISI - 1
      NT = ISTACK(ISI)
      IS = IS - 1
      CRATE = STACK(IS)
      IS = IS - 1
      AMAXR = STACK(IS)
      IS = IS - 1
      AMAXL = STACK(IS)
      IS = IS - 1
      SUB3 = STACK(IS)
      IS = IS - 1
      SUB1 = STACK(IS)
      IS = IS - 1
      FACTOR = STACK(IS)
      GO TO 20
C
C     SUBDIVISION RESULT
  180 IF (ABS(D01AHF).GT.100.0D0*UFLOW)
     *    RELERR = ABS(RELERR/D01AHU(D01AHF))
      RELERR = MAX(RELERR,0.5D0*EPMACH)
      IF (IC.NE.1) GO TO 200
      IFAIL = 0
      RETURN
  200 IL = 2
      IF (IC.LT.0) GO TO 220
      IL = 1
  220 IFAIL = P01ABF(ICQ,IL,SRNAME,0,P01REC)
      RETURN
      END

C     =========================================================
C     =================== D01AHY ==============================
C     =========================================================

      SUBROUTINE D01AHY(A,B,RESULT,K,EPSIL,NPTS,ICHECK,F,AMAXL,AMAXR,R1,
     *                  IT)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     CONTROLS BASIC ALGORITHM D01AHX, APPLYING A FURTHER RANDOM
C     TRANSFORMATION IF CONVERGENCE WAS ACHIEVED AS A RESULT OF THE
C     E-ALGORITHM TO IMPROVE RELIABILITY
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, AMAXL, AMAXR, B, EPSIL, R1
      INTEGER           ICHECK, IT, K, NPTS
C     .. Array Arguments ..
      DOUBLE PRECISION  RESULT(8)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Scalars in Common ..
      DOUBLE PRECISION  ALP, AV, FZERO
      INTEGER           IR, NT
C     .. Arrays in Common ..
      DOUBLE PRECISION  FUNCTM(127), FUNCTP(127)
C     .. Local Scalars ..
      DOUBLE PRECISION  ALAST, ERR, XDUM
      INTEGER           IQ, NF
C     .. External Functions ..
      DOUBLE PRECISION  D01AHU, G05CAF
      EXTERNAL          D01AHU, G05CAF
C     .. External Subroutines ..
      EXTERNAL          D01AHV, D01AHX
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Common blocks ..
      COMMON            /BD01AH/FUNCTP, FUNCTM, FZERO
      COMMON            /CD01AH/ALP, AV, NT, IR
C     .. Executable Statements ..
      NPTS = 0
      IR = 0
      IQ = 0
C
C     RANDOM TRANSFORMATION PARAMETER
C     USE STANDARD NAG ROUTINE G05CAF FOR RANDOM NUMBER
   20 ALP = (2.0D0*G05CAF(XDUM)-1.0D0)*0.01D0/D01AHU(B-A)
      CALL D01AHX(A,B,RESULT,K,EPSIL,NF,ICHECK,F,AMAXL,AMAXR,R1,IT)
      NPTS = NPTS + NF
      IF (ICHECK.EQ.0) GO TO 100
      IF (ICHECK.NE.4) RETURN
C
C     CONVERGED USING E-ALGORITHM
      IF (IQ.EQ.0) GO TO 60
   40 ERR = ABS(ALAST-RESULT(K))
      IF (ERR.LE.ABS(ALAST)*EPSIL) GO TO 80
      IF (K.LT.5) GO TO 120
C
C     CALCULATE VARIATION ON LEFT AND RIGHT
      CALL D01AHV(A,B,AMAXL,AMAXR)
      RETURN
C
C     CHECK RESULT
   60 IQ = 1
      ALAST = RESULT(K)
      IR = 1
      GO TO 20
   80 ICHECK = 0
      RETURN
  100 IF (IQ.EQ.0) RETURN
C
C     ICHECK = 4  INDICATES THAT A CONVERGED RESULT WAS OBTAINED
C     AFTER
C     APPLYING E- ALGORITHM.
      ICHECK = 4
      GO TO 40
  120 AMAXL = 0.0D0
      AMAXR = 0.0D0
      RETURN
      END

C     =========================================================
C     =========================  d01AHX =======================
C     =========================================================

      SUBROUTINE D01AHX(A,B,RESULT,K,EPSIL,NPTS,ICHECK,F,AMAXL,AMAXR,R1,
     *                  IT)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 8A REVISED. IER-255 (AUG 1980).
C     MARK 10A REVISED. IER-388 (OCT 1982).
C     MARK 10B REVISED. IER-413 (JAN 1983).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 12B REVISED. IER-526 (FEB 1987).
C     MARK 13B REVISED. IER-652 (AUG 1988).
C
C     THIS ROUTINE SHOULD NOT BE CALLED DIRECTLY BUT UNDER
C     THE CONTROL OF  D01AHF  WHICH INITIALIZES
C     TRANSFORMATION PARAMETERS USED IN  D01AHW.
C     THIS SUBROUTINE ATTEMPTS TO CALCULATE THE INTEGRAL F(X)
C     OVER THE INTERVAL (A,B) WITH RELATIVE ERROR NOT
C     EXCEEDING EPSIL.
C     THE RESULT OBTAINED USING A SEQUENCE OF 1, 3, 7, 15, 31,
C     63, 127 AND 255 POINTS INTERLACING QUADRATURE RULES
C     BASED ON THE OPTIMAL EXTENSION OF THE 3 POINT GAUSS
C     RULE. (SEE PATTERSON,T.N.L.,
C     MATH.COMP,22,847-857,1968). ADDITIONALLY, THE
C     EPSILON-ALGORITHM  TABLEAU IS DEVELOPED
C     (WYNN,MTAC,VOL 10,91,1956) ALONG WITH THE SEQUENCE OF
C     RULES AND CONVERGENCE IS DEEMED TO HAVE OCCURRED WHEN
C     ON SCANNING THE TABLEAU THE LAST TWO MEMBERS OF A
C     COLUMN  (THE FIRST COLUMN BEING TAKEN AS THE RESULTS
C     OF THE SEQUENCE OF RULES) OR LAST MEMBERS OF ADJACENT
C     COLUMNS AGREE TO THE SPECIFIED RELATIVE ACCURACY.
C     IF CONVERGENCE HAS NOT BEEN ACHIEVED FOR THE 31 POINT RULE
C     AND  CRATE.LE.30  THEN THE INTEGRATION IS ABORTED,
C     OTHERWISE THE HIGHER ORDER RULES ARE INVOKED. IF
C     R1,R2 AND R3  ARE THE RESULTS OF THREE SUCCESSIVE
C     RULES THEN  CRATE=ABS((R1-R2)/(R2-R3)). THIS IS ALSO
C     USED IN THE SUBDIVISION STRATEGY.
C     THE ARGUMENTS ARE -
C     A       -  LOWER LIMIT OF INTEGRATION
C     B       -  UPPER LIMIT OF INTEGRATION
C     EPSIL   -  RELATIVE ACCURACY REQUIRED
C     F       -  F(Z,W)  IS A USER NAMED AND WRITTEN FUNCTION
C                EVALUATING THE INTEGRAND AT Z+W
C     RESULT  -  THIS ARRAY SHOULD BE DECLARED WITH AT LEAST 8
C                ELEMENTS.  IT NORMALLY HOLDS THE RESULTS OF THE
C                SEQUENCE OF RULES EXCEPT WHEN CONVERGENCE IS
C                OBTAINED FROM THE E-ALGORITHM WHEN THE LAST TWO
C                MEMBERS WILL CONTAIN THE LAST COMPARISONS.
C     K       -  RESULT(K)  HOLDS THE INTEGRAL VALUE TO THE
C                SPECIFIED ACCURACY.
C     NPTS    -  NUMBER OF INTEGRAND EVALUATIONS.
C     ICHECK  -  INDICATES THE OUTCOME OF THE INTEGRATION -
C                ICHECK = 0  CONVERGENCE USING THE SEQUENCE OF
C                            RULES ONLY OR USING THE SEQUENCE OF
C                            RULES AND E1 WHEN AT LEAST 15 POINTS
C                            HAVE BEEN USED.
C                ICHECK = 4  CONVERGENCE FROM THE EPSILON ALGORITHM
C                            TABLEAU (NORMALLY ACCURATE BUT LESS
C                            RELIABLE THAN  ICHECK = 0)
C                ICHECK = 1  CONVERGENCE NOT ACHIEVED
C     IT,R1   -  WHEN  IT  IS NON-ZERO A SINGULARITY WEAKENING
C                TRANSFORMATION WILL BE APPLIED AT ENDPOINT
C                 R1  USING SUBROUTINE  D01AHW.
C     AMAXL,AMAXR
C             -  WHEN CONVERGENCE IS NOT ACHIEVED INFORMATION IS
C                GENERATED ON THE RELATIVE GRADIENTS OF THE
C                INTEGRAND AT A (SIZE AMAXL) AND B (SIZE
C                AMAXR) USING THE SUBROUTINE D01AHV
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, AMAXL, AMAXR, B, EPSIL, R1
      INTEGER           ICHECK, IT, K, NPTS
C     .. Array Arguments ..
      DOUBLE PRECISION  RESULT(8)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Scalars in Common ..
      DOUBLE PRECISION  AFLOW, CRATE, EPMACH, FZERO, UFLOW
      INTEGER           MRULE
C     .. Arrays in Common ..
      DOUBLE PRECISION  FUNCTM(127), FUNCTP(127)
C     .. Local Scalars ..
      DOUBLE PRECISION  ACUM
      DOUBLE PRECISION  A2, A3, B2, B3, C2, C3, DIFF, FABS, P2, P3, Q2,
     *                  Q3, R2, R3, SUM, T0, T1, T2, T3, T4, TEMP, TEST,
     *                  X, Y
      INTEGER           I, IW, K1, KP, LP, NB, NTOP
C     .. Local Arrays ..
      DOUBLE PRECISION  P(127), W(254)
      LOGICAL           BAD(8)
C     .. External Functions ..
      DOUBLE PRECISION  D01AHU
      EXTERNAL          D01AHU
C     .. External Subroutines ..
      EXTERNAL          D01AHV, D01AHW
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX
C     .. Common blocks ..
      COMMON            /AD01AH/CRATE, MRULE
      COMMON            /BD01AH/FUNCTP, FUNCTM, FZERO
      COMMON            /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Statement Functions ..
      LOGICAL           COMPAR
C     .. Data statements ..
      DATA              A3, B3, C3, P3, Q3, R3/6*0.0D0/
      DATA              P(1), P(2), P(3), P(4), P(5), P(6), P(7), P(8),
     *                  P(9), P(10), P(11), P(12), P(13), P(14), P(15),
     *                  P(16), P(17), P(18), P(19), P(20), P(21), P(22),
     *                  P(23), P(24), P(25), P(26), P(27), P(28)/
     *    .999997596379748464620D 0,.999982430354891598580D 0,
     *    .999943996207054375764D 0,.999872888120357611938D 0,
     *    .999760490924432047330D 0,.999598799671910683252D 0,
     *    .999380338025023581928D 0,.999098124967667597662D 0,
     *    .998745614468095114704D 0,.998316635318407392531D 0,
     *    .997805354495957274562D 0,.997206259372221959076D 0,
     *    .996514145914890273849D 0,.995724104698407188509D 0,
     *    .994831502800621000519D 0,.993831963212755022209D 0,
     *    .992721344282788615328D 0,.991495721178106132398D 0,
     *    .990151370400770159181D 0,.988684757547429479939D 0,
     *    .987092527954034067190D 0,.985371499598520371114D 0,
     *    .983518657578632728762D 0,.981531149553740106867D 0,
     *    .979406281670862683806D 0,.977141514639705714156D 0,
     *    .974734459752402667761D 0,.972182874748581796578D 0/
      DATA              P(29), P(30), P(31), P(32), P(33), P(34), P(35),
     *                  P(36), P(37), P(38), P(39), P(40), P(41), P(42),
     *                  P(43), P(44), P(45), P(46), P(47), P(48), P(49),
     *                  P(50), P(51), P(52), P(53), P(54), P(55), P(56)/
     *    .969484659502459231771D 0,.966637851558416567092D 0,
     *    .963640621569812132521D 0,.960491268708020283423D 0,
     *    .957188216109860962736D 0,.953730006425761136415D 0,
     *    .950115297521294876558D 0,.946342858373402905148D 0,
     *    .942411565191083059813D 0,.938320397779592883655D 0,
     *    .934068436157725787999D 0,.929654857429740056670D 0,
     *    .925078932907075652364D 0,.920340025470012420730D 0,
     *    .915437587155765040644D 0,.910371156957004292498D 0,
     *    .905140358813261595189D 0,.899744899776940036639D 0,
     *    .894184568335559022859D 0,.888459232872256998890D 0,
     *    .882568840247341906842D 0,.876513414484705269742D 0,
     *    .870293055548113905851D 0,.863907938193690477146D 0,
     *    .857358310886232156525D 0,.850644494768350279758D 0,
     *    .843766882672708601038D 0,.836725938168868735503D 0/
      DATA              P(57), P(58), P(59), P(60), P(61), P(62), P(63),
     *                  P(64), P(65), P(66), P(67), P(68), P(69), P(70),
     *                  P(71), P(72), P(73), P(74), P(75), P(76), P(77),
     *                  P(78), P(79), P(80), P(81), P(82), P(83), P(84)/
     *    .829522194637401400178D 0,.822156254364980407373D 0,
     *    .814628787655137413436D 0,.806940531950217611856D 0,
     *    .799092290960841401800D 0,.791084933799848361435D 0,
     *    .782919394118283016385D 0,.774596669241483377036D 0,
     *    .766117819303760090717D 0,.757483966380513637926D 0,
     *    .748696293616936602823D 0,.739756044352694758677D 0,
     *    .730664521242181261329D 0,.721423085370098915485D 0,
     *    .712033155362252034587D 0,.702496206491527078610D 0,
     *    .692813769779114702895D 0,.682987431091079228087D 0,
     *    .673018830230418479199D 0,.662909660024780595461D 0,
     *    .652661665410017496101D 0,.642276642509759513774D 0,
     *    .631756437711194230414D 0,.621102946737226402941D 0,
     *    .610318113715186400156D 0,.599403930242242892974D 0,
     *    .588362434447662541434D 0,.577195710052045814844D 0/
      DATA              P(85), P(86), P(87), P(88), P(89), P(90), P(91),
     *                  P(92), P(93), P(94), P(95), P(96), P(97), P(98),
     *                  P(99), P(100), P(101), P(102), P(103), P(104),
     *                  P(105), P(106), P(107), P(108), P(109), P(110),
     *                  P(111), P(112)/
     *    .565905885423654422623D 0,.554495132631932548866D 0,
     *    .542965666498311490492D 0,.531319743644375623972D 0,
     *    .519559661537457021993D 0,.507687757533716602155D 0,
     *    .495706407918761460170D 0,.483618026945841027562D 0,
     *    .471425065871658876934D 0,.459130011989832332873D 0,
     *    .446735387662028473742D 0,.434243749346802558002D 0,
     *    .421657686626163300056D 0,.408979821229888672409D 0,
     *    .396212806057615939183D 0,.383359324198730346916D 0,
     *    .370422087950078230138D 0,.357403837831532152376D 0,
     *    .344307341599438022777D 0,.331135393257976833093D 0,
     *    .317890812068476683182D 0,.304576441556714043335D 0,
     *    .291195148518246681964D 0,.277749822021824315065D 0,
     *    .264243372410926761945D 0,.250678730303483176613D 0,
     *    .237058845589829727213D 0,.223386686428966881628D 0/
      DATA              P(113), P(114), P(115), P(116), P(117), P(118),
     *                  P(119), P(120), P(121), P(122), P(123), P(124),
     *                  P(125), P(126), P(127)/
     *    .209665238243181194766D 0,.195897502711100153915D 0,
     *    .182086496759252198246D 0,.168235251552207464982D 0,
     *    .154346811481378108692D 0,.140424233152560174594D 0,
     *    .126470584372301966851D 0,.112488943133186625746D 0,
     *    .984823965981192020903D-1,.844540400837108837102D-1,
     *    .704069760428551790633D-1,.563443130465927899720D-1,
     *    .422691647653636032124D-1,.281846489497456943394D-1,
     *    .140938864107824626142D-1/
      DATA              W(1), W(2), W(3), W(4), W(5), W(6), W(7), W(8),
     *                  W(9), W(10), W(11), W(12), W(13), W(14), W(15),
     *                  W(16), W(17), W(18), W(19), W(20), W(21), W(22),
     *                  W(23), W(24), W(25), W(26), W(27), W(28)/
     *    .555555555555555555556D 0,.888888888888888888889D 0,
     *    .104656226026467265194D 0,.268488089868333440729D 0,
     *    .401397414775962222905D 0,.450916538658474142345D 0,
     *    .170017196299402603390D-1,.516032829970797396969D-1,
     *    .929271953151245376859D-1,.134415255243784220360D 0,
     *    .171511909136391380787D 0,.200628529376989021034D 0,
     *    .219156858401587496404D 0,.225510499798206687386D 0,
     *    .254478079156187441540D-2,.843456573932110624631D-2,
     *    .164460498543878109338D-1,.258075980961766535646D-1,
     *    .359571033071293220968D-1,.464628932617579865414D-1,
     *    .569795094941233574122D-1,.672077542959907035404D-1,
     *    .768796204990035310427D-1,.857559200499903511542D-1,
     *    .936271099812644736167D-1,.100314278611795578771D 0,
     *    .105669893580234809744D 0,.109578421055924638237D 0/
      DATA              W(29), W(30), W(31), W(32), W(33), W(34), W(35),
     *                  W(36), W(37), W(38), W(39), W(40), W(41), W(42),
     *                  W(43), W(44), W(45), W(46), W(47), W(48), W(49),
     *                  W(50), W(51), W(52), W(53), W(54), W(55), W(56)/
     *    .111956873020953456880D 0,.112755256720768691607D 0,
     *    .363221481845530659694D-3,.126515655623006801137D-2,
     *    .257904979468568827243D-2,.421763044155885483908D-2,
     *    .611550682211724633968D-2,.822300795723592966926D-2,
     *    .104982469096213218983D-1,.129038001003512656260D-1,
     *    .154067504665594978021D-1,.179785515681282703329D-1,
     *    .205942339159127111492D-1,.232314466399102694433D-1,
     *    .258696793272147469108D-1,.284897547458335486125D-1,
     *    .310735511116879648799D-1,.336038771482077305417D-1,
     *    .360644327807825726401D-1,.384398102494555320386D-1,
     *    .407155101169443189339D-1,.428779600250077344929D-1,
     *    .449145316536321974143D-1,.468135549906280124026D-1,
     *    .485643304066731987159D-1,.501571393058995374137D-1,
     *    .515832539520484587768D-1,.528349467901165198621D-1/
      DATA              W(57), W(58), W(59), W(60), W(61), W(62), W(63),
     *                  W(64), W(65), W(66), W(67), W(68), W(69), W(70),
     *                  W(71), W(72), W(73), W(74), W(75), W(76), W(77),
     *                  W(78), W(79), W(80), W(81), W(82), W(83), W(84)/
     *    .539054993352660639269D-1,.547892105279628650322D-1,
     *    .554814043565593639878D-1,.559784365104763194076D-1,
     *    .562776998312543012726D-1,.563776283603847173877D-1,
     *    .505360952078625176247D-4,.180739564445388357820D-3,
     *    .377746646326984660274D-3,.632607319362633544219D-3,
     *    .938369848542381500794D-3,.128952408261041739210D-2,
     *    .168114286542146990631D-2,.210881524572663287933D-2,
     *    .256876494379402037313D-2,.305775341017553113613D-2,
     *    .357289278351729964938D-2,.411150397865469304717D-2,
     *    .467105037211432174741D-2,.524912345480885912513D-2,
     *    .584344987583563950756D-2,.645190005017573692280D-2,
     *    .707248999543355546805D-2,.770337523327974184817D-2,
     *    .834283875396815770558D-2,.898927578406413572328D-2,
     *    .964117772970253669530D-2,.102971169579563555237D-1/
      DATA              W(85), W(86), W(87), W(88), W(89), W(90), W(91),
     *                  W(92), W(93), W(94), W(95), W(96), W(97), W(98),
     *                  W(99), W(100), W(101), W(102), W(103), W(104),
     *                  W(105), W(106), W(107), W(108), W(109), W(110),
     *                  W(111), W(112)/
     *    .109557333878379016480D-1,.116157233199551347270D-1,
     *    .122758305600827700870D-1,.129348396636073734547D-1,
     *    .135915710097655467896D-1,.142448773729167743063D-1,
     *    .148936416648151820348D-1,.155367755558439824399D-1,
     *    .161732187295777199419D-1,.168019385741038652709D-1,
     *    .174219301594641737472D-1,.180322163903912863201D-1,
     *    .186318482561387901863D-1,.192199051247277660193D-1,
     *    .197954950480974994880D-1,.203577550584721594669D-1,
     *    .209058514458120238522D-1,.214389800125038672465D-1,
     *    .219563663053178249393D-1,.224572658268160987071D-1,
     *    .229409642293877487608D-1,.234067774953140062013D-1,
     *    .238540521060385400804D-1,.242821652033365993580D-1,
     *    .246905247444876769091D-1,.250785696529497687068D-1,
     *    .254457699654647658126D-1,.257916269760242293884D-1/
      DATA              W(113), W(114), W(115), W(116), W(117), W(118),
     *                  W(119), W(120), W(121), W(122), W(123), W(124),
     *                  W(125), W(126), W(127), W(128), W(129), W(130),
     *                  W(131), W(132), W(133), W(134), W(135), W(136),
     *                  W(137), W(138), W(139), W(140)/
     *    .261156733767060976805D-1,.264174733950582599310D-1,
     *    .266966229274503599062D-1,.269527496676330319634D-1,
     *    .271855132296247918192D-1,.273946052639814325161D-1,
     *    .275797495664818730349D-1,.277407021782796819939D-1,
     *    .278772514766137016085D-1,.279892182552381597038D-1,
     *    .280764557938172466068D-1,.281388499156271506363D-1,
     *    .281763190330166021307D-1,.281888141801923586938D-1,
     *    .693793643241082671695D-5,.251578703842806614886D-4,
     *    .532752936697806131254D-4,.903727346587511492612D-4,
     *    .135754910949228719730D-3,.188873264506504913661D-3,
     *    .249212400482997294025D-3,.316303660822264476886D-3,
     *    .389745284473282293216D-3,.469184924247850409755D-3,
     *    .554295314930374714918D-3,.644762041305724779327D-3,
     *    .740282804244503330463D-3,.840571432710722463647D-3/
      DATA              W(141), W(142), W(143), W(144), W(145), W(146),
     *                  W(147), W(148), W(149), W(150), W(151), W(152),
     *                  W(153), W(154), W(155), W(156), W(157), W(158),
     *                  W(159), W(160), W(161), W(162), W(163), W(164),
     *                  W(165), W(166), W(167), W(168)/
     *    .945361516858525382463D-3,.105440762286331677225D-2,
     *    .116748411742995940769D-2,.128438247189701017681D-2,
     *    .140490799565514464272D-2,.152887670508776556838D-2,
     *    .165611272815445260522D-2,.178644639175864982468D-2,
     *    .191971297101387241252D-2,.205575198932734652359D-2,
     *    .219440692536383883880D-2,.233552518605716087370D-2,
     *    .247895822665756793068D-2,.262456172740442956257D-2,
     *    .277219576459345099400D-2,.292172493791781975378D-2,
     *    .307301843470257832341D-2,.322595002508786846140D-2,
     *    .338039799108692038235D-2,.353624499771677773402D-2,
     *    .369337791702565081826D-2,.385168761663987092408D-2,
     *    .401106872407502339889D-2,.417141937698407885279D-2,
     *    .433264096809298285454D-2,.449463789203206786164D-2,
     *    .465731729975685477728D-2,.482058886485126834765D-2/
      DATA              W(169), W(170), W(171), W(172), W(173), W(174),
     *                  W(175), W(176), W(177), W(178), W(179), W(180),
     *                  W(181), W(182), W(183), W(184), W(185), W(186),
     *                  W(187), W(188), W(189), W(190), W(191), W(192),
     *                  W(193), W(194), W(195), W(196)/
     *    .498436456476553860120D-2,.514855847897817776184D-2,
     *    .531308660518705656629D-2,.547786669391895082402D-2,
     *    .564281810138444415845D-2,.580786165997756736349D-2,
     *    .597291956550816580495D-2,.613791528004138504348D-2,
     *    .630277344908575871716D-2,.646741983180368672737D-2,
     *    .663178124290188789412D-2,.679578550488277339479D-2,
     *    .695936140939042293944D-2,.712243868645838715317D-2,
     *    .728494798055380706388D-2,.744682083240759101741D-2,
     *    .760798966571905658322D-2,.776838777792199121996D-2,
     *    .792794933429484911025D-2,.808660936478885997097D-2,
     *    .824430376303286803055D-2,.840096928705193263543D-2,
     *    .855654356130768961917D-2,.871096507973208687358D-2,
     *    .886417320948249426411D-2,.901610819519564316003D-2,
     *    .916671116356078840671D-2,.931592412806939509316D-2/
      DATA              W(197), W(198), W(199), W(200), W(201), W(202),
     *                  W(203), W(204), W(205), W(206), W(207), W(208),
     *                  W(209), W(210), W(211), W(212), W(213), W(214),
     *                  W(215), W(216), W(217), W(218), W(219), W(220),
     *                  W(221), W(222), W(223), W(224)/
     *    .946368999383006529427D-2,.960995256236388300966D-2,
     *    .975465653631741146108D-2,.989774752404874974401D-2,
     *    .100391720440568407982D-1,.101788775292360797335D-1,
     *    .103168123309476216819D-1,.104529257229060119261D-1,
     *    .105871679048851979309D-1,.107194900062519336232D-1,
     *    .108498440893373140990D-1,.109781831526589124696D-1,
     *    .111044611340069265370D-1,.112286329134080493536D-1,
     *    .113506543159805966017D-1,.114704821146938743804D-1,
     *    .115880740330439525684D-1,.117033887476570031007D-1,
     *    .118163858908302357632D-1,.119270260530192700402D-1,
     *    .120352707852795626304D-1,.121410826016682996790D-1,
     *    .122444249816119858986D-1,.123452623722438384545D-1,
     *    .124435601907140352631D-1,.125392848264748843534D-1,
     *    .126324036435420787645D-1,.127228849827323829063D-1/
      DATA              W(225), W(226), W(227), W(228), W(229), W(230),
     *                  W(231), W(232), W(233), W(234), W(235), W(236),
     *                  W(237), W(238), W(239), W(240), W(241), W(242),
     *                  W(243), W(244), W(245), W(246), W(247), W(248),
     *                  W(249), W(250), W(251), W(252)/
     *    .128106981638773619668D-1,.128958134880121146942D-1,
     *    .129782022395373992858D-1,.130578366883530488402D-1,
     *    .131346900919601528364D-1,.132087366975291299655D-1,
     *    .132799517439305306504D-1,.133483114637251799531D-1,
     *    .134137930851100985130D-1,.134763748338165159817D-1,
     *    .135360359349562136137D-1,.135927566148123959096D-1,
     *    .136465181025712914284D-1,.136973026319907162581D-1,
     *    .137450934430018966323D-1,.137898747832409365174D-1,
     *    .138316319095064286765D-1,.138703510891398409970D-1,
     *    .139060196013254612635D-1,.139386257383068508043D-1,
     *    .139681588065169385157D-1,.139946091276190798519D-1,
     *    .140179680394566088099D-1,.140382278969086233034D-1,
     *    .140553820726499642772D-1,.140694249578135753181D-1,
     *    .140803519625536613248D-1,.140881595165083010653D-1/
      DATA              W(253), W(254)/
     *    .140928450691604083550D-1,.140944070900961793469D-1/
C     .. Statement Function definitions ..
      COMPAR(Y) = ABS(Y) .LE. TEST .OR. (TEST.LT.ABS(Y) .AND. ABS(Y)
     *            .LE.10.0D0*ABS(FABS)*EPMACH)
C     .. Executable Statements ..
      ICHECK = 0
      MRULE = 8
C
C     CHECK FOR TRIVAL CASE
      IF (ABS(A-B).LE.MAX(ABS(A),ABS(B))*EPMACH*10.0D0) GO TO 240
      IW = 0
      K = 1
      T1 = 0.0D0
      NB = 128
      NTOP = 0
      LP = 0
C
C     SCALE FACTORS
      SUM = (B+A)*0.5D0
      DIFF = (B-A)*0.5D0
      CALL D01AHW(F,SUM,A,B,R1,FZERO,IT)
C
C     1-POINT GAUSS
      RESULT(1) = 2.0D0*FZERO*DIFF
   20 IF (K.EQ.MRULE) GO TO 200
      IF (K.EQ.5 .AND. CRATE.LE.30.0D0) GO TO 200
      K = K + 1
      NB = NB/2
      LP = LP + LP + 1
      NTOP = NTOP + NB
      ACUM = 0.0D0
      KP = 0
      FABS = 0.0D0
      DO 60 I = NB, NTOP, NB
	 IW = IW + 1
	 KP = 1 - KP
	 IF (KP.EQ.0) GO TO 40
	 X = P(I)*DIFF
	 CALL D01AHW(F,SUM+X,A,B,R1,FUNCTP(I),IT)
	 CALL D01AHW(F,SUM-X,A,B,R1,FUNCTM(I),IT)
   40    ACUM = ACUM + W(IW)*(FUNCTP(I)+FUNCTM(I))
	 FABS = FABS + W(IW)*(ABS(FUNCTP(I))+ABS(FUNCTM(I)))
   60 CONTINUE
      IW = IW + 1
      RESULT(K) = (ACUM+W(IW)*FZERO)*DIFF
      FABS = (FABS+W(IW)*ABS(FZERO))*DIFF
C
C     CHECK FOR CONVERGENCE
      TEST = EPSIL*ABS(RESULT(K))
      T0 = T1
      T1 = RESULT(K) - RESULT(K-1)
      IF (K.LT.3) GO TO 80
      BAD(K) = ABS(T1) .GT. ABS(T0)
C
C     CONVERGENCE RATE
      CRATE = 0.0D0
      IF (ABS(T0).GT.21.0D0*ABS(T1)) CRATE = 22.0D0
      IF (ABS(T0).GT.30.0D0*ABS(T1)) CRATE = 31.0D0
      IF (COMPAR(T1)) GO TO 220
C     E-ALGORITHM
   80 P2 = P3
      P3 = 1.0D0/D01AHU(T1)
      IF (K.EQ.2) GO TO 20
      A2 = A3
      TEMP = 1.0D0/D01AHU(P3-P2)
      A3 = RESULT(K-1) + TEMP
      IF (K.EQ.3) GO TO 20
      TEMP = A3 - RESULT(K)
      K1 = MAX(K-2,3)
      DO 90 I = K1, K
	 IF (BAD(I)) GO TO 100
   90 CONTINUE
      IF ( .NOT. COMPAR(TEMP)) GO TO 100
      RESULT(K-1) = RESULT(K)
      RESULT(K) = A3
      GO TO 220
  100 T2 = A3 - A2
      K1 = MAX(K-3,3)
      DO 110 I = K1, K
	 IF (BAD(I)) GO TO 120
  110 CONTINUE
      IF ( .NOT. COMPAR(T2)) GO TO 120
      RESULT(K-1) = A2
      RESULT(K) = A3
      GO TO 220
  120 Q2 = Q3
      Q3 = 1.0D0/D01AHU(T2) + P2
      IF (K.EQ.4) GO TO 20
      TEMP = 1.0D0/D01AHU(Q3-Q2)
      B2 = B3
      B3 = A2 + TEMP
      TEMP = B3 - A3
      K1 = MAX(K-4,3)
      DO 130 I = K1, K
	 IF (BAD(I)) GO TO 140
  130 CONTINUE
      IF ( .NOT. COMPAR(TEMP)) GO TO 140
      RESULT(K-1) = A3
      RESULT(K) = B3
      GO TO 260
  140 IF (K.EQ.5) GO TO 20
      T3 = B3 - B2
      K1 = MAX(K-5,3)
      DO 150 I = K1, K
	 IF (BAD(I)) GO TO 160
  150 CONTINUE
      IF ( .NOT. COMPAR(T3)) GO TO 160
      RESULT(K-1) = B2
      RESULT(K) = B3
      GO TO 260
  160 R2 = R3
      R3 = 1.0D0/D01AHU(T3) + Q2
      IF (K.EQ.6) GO TO 20
      C2 = C3
      TEMP = 1.0D0/D01AHU(R3-R2)
      C3 = B2 + TEMP
      TEMP = C3 - B3
      K1 = MAX(K-6,3)
      DO 170 I = K1, K
	 IF (BAD(I)) GO TO 180
  170 CONTINUE
      IF ( .NOT. COMPAR(TEMP)) GO TO 180
      RESULT(K-1) = B3
      RESULT(K) = C3
      GO TO 260
  180 IF (K.EQ.7) GO TO 20
      T4 = C3 - C2
      K1 = MAX(K-7,3)
      DO 190 I = K1, K
	 IF (BAD(I)) GO TO 20
  190 CONTINUE
      IF ( .NOT. COMPAR(T4)) GO TO 20
      RESULT(K-1) = C2
      RESULT(K) = C3
      GO TO 260
C
C     CONVERGENCE NOT ACHIEVED
  200 ICHECK = 1
      IF (K.LT.5) GO TO 280
C
C     CALCULATE VARIATION ON LEFT AND RIGHT
C     HALVES OF (A,B).
      CALL D01AHV(A,B,AMAXL,AMAXR)
C
C     NORMAL TERMINATION - DIRECT CONVERGENCE OR CONVERGENCE OF
C     E-ALGORITHM BEFORE THIRD LEVEL
  220 NPTS = LP + LP + 1
      RETURN
C
C     TRIVAL CASE
  240 K = 2
      RESULT(1) = 0.0D0
      RESULT(2) = 0.0D0
      NPTS = 0
      RETURN
C
C     CONVERGENCE OF E-ALGORITHM ONLY AT THIRD LEVEL - CONFIRMATION
C     NEEDED
  260 ICHECK = 4
      GO TO 220
  280 AMAXL = 0.0D0
      AMAXR = 0.0D0
      GO TO 220
      END

C     ========================================================
C     =================  D01AHV ==============================
C     ========================================================

      SUBROUTINE D01AHV(A,B,AMAXL,AMAXR)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     CALCULATES THE RELATIVE GRADIENTS AT A AND B (RESPECTIVE SIZES
C     AMAXL AND AMAXR)
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, AMAXL, AMAXR, B
C     .. Scalars in Common ..
      DOUBLE PRECISION  FZERO
C     .. Arrays in Common ..
      DOUBLE PRECISION  FUNCTM(127), FUNCTP(127)
C     .. Local Scalars ..
      DOUBLE PRECISION  D1, D30, P, Q, SUM, T
      INTEGER           I, J
C     .. Local Arrays ..
      DOUBLE PRECISION  PIV(15)
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Common blocks ..
      COMMON            /BD01AH/FUNCTP, FUNCTM, FZERO
C     .. Data statements ..
C
C     5 DIGITS ARE SUFFICIENT HERE FOR PIV (31-POINT RULE NODES)
      DATA              PIV(1), PIV(2), PIV(3), PIV(4), PIV(5), PIV(6),
     *                  PIV(7), PIV(8), PIV(9), PIV(10), PIV(11),
     *                  PIV(12), PIV(13), PIV(14), PIV(15)/.99910D0,
     *                  .99383D0, .98153D0, .96049D0, .92965D0,
     *                  .88846D0, .83673D0, .77460D0, .70250D0,
     *                  .62110D0, .53132D0, .43424D0, .33114D0,
     *                  .22339D0, .11249D0/
C     .. Executable Statements ..
      SUM = 0.0D0
      DO 20 J = 1, 14
	 I = J*8
	 T = PIV(J) - PIV(J+1)
	 P = (FUNCTM(I+8)-FUNCTM(I))/T
	 Q = (FUNCTP(I)-FUNCTP(I+8))/T
	 SUM = SUM + ABS(P) + ABS(Q)
   20 CONTINUE
      T = PIV(15)
      P = (-FUNCTM(120)+FZERO)/T
      Q = (-FZERO+FUNCTP(120))/T
      T = PIV(1) - PIV(2)
      D1 = (FUNCTM(16)-FUNCTM(8))/T
      D30 = (FUNCTP(8)-FUNCTP(16))/T
      SUM = SUM + ABS(P) + ABS(Q)
      AMAXL = ABS(D1)/SUM
      AMAXR = ABS(D30)/SUM
      RETURN
      END

C     ======================================================
C     =================== D01AHZ ===========================
C     ======================================================


      DOUBLE PRECISION FUNCTION D01AHZ(S1,S3,AL,AR)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     SUBDIVIDE IN RATIO 1/2 IF INTEGRAND IS STEEPER ON LEFT OR
C                        2/1 IF STEEPER ON RIGHT
C                        1/1 OTHERWISE
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 AL,AR, S1, S3
C     .. Executable Statements ..
      IF (AL-AR) 20, 40, 60
   20 D01AHZ = (S1+2.0D0*S3)/3.0D0
      RETURN
   40 D01AHZ = (S1+S3)/2.0D0
      RETURN
   60 D01AHZ = (2.0D0*S1+S3)/3.0D0
      RETURN
      END

C     ===============================================================
C     ====================== D01AHU =================================
C     ===============================================================


      DOUBLE PRECISION FUNCTION D01AHU(A)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 14 REVISED. IER-820 (DEC 1989).
C     USED TO AVOID ZERO DIVISIONS.
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 A
C     .. Scalars in Common ..
      DOUBLE PRECISION                 AFLOW, EPMACH, UFLOW
C     .. Intrinsic Functions ..
      INTRINSIC                        ABS, MAX, SIGN
C     .. Common blocks ..
      COMMON                           /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Executable Statements ..
      D01AHU = 10.0D0*UFLOW
      IF (A.EQ.0.0D0) RETURN
      D01AHU = SIGN(MAX(ABS(A),10.0D0*UFLOW),A)
      RETURN
      END





C     ========================================================
C     ===================== D01AHW  ==========================
C     ========================================================

      SUBROUTINE D01AHW(F,V,A,B,R1,VAL,IT)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     CALCULATES THE VALUE OF THE TRANSFORMED INTEGRAND.
C     A RANDOM TRANSFORMATION (IR NON-ZERO, AND CONTROLLED BY ALP)
C     AND POSSIBLY A SINGULARITY WEAKENING TRANSFORMATION
C     (IT NON-ZERO, AND CONTROLLED BY NT) WILL BE APPLIED.
C     WITH A POSSIBLE SINGULARITY AT ENDPOINT  R1  THE
C     TRANSFORMATION OF VARIABLE IS
C
C                X = (T-A)**(NT+1)/(B-A)**NT+A,  R1=A
C          OR    X = (T-B)**(NT+1)/(A-B)**NT+B,  R1=B
C
C     THE RANDOM TRANSFORMATION IS -
C
C                X = A*B*ALP+(1-ALP*(A+B))*T+ALP*T**2
C
C     WHERE  ALP*(B-A)  IS    RANDOM IN  (-.01,.01).
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, B, R1, V, VAL
      INTEGER           IT
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Scalars in Common ..
      DOUBLE PRECISION  AFLOW, ALP, AV, EPMACH, UFLOW
      INTEGER           IR, NT
C     .. Local Scalars ..
      DOUBLE PRECISION  ELIM, GM, PART, Q, RK, S, SLOPE, SLOPER, T, W, X
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, EXP, DBLE
C     .. Common blocks ..
      COMMON            /CD01AH/ALP, AV, NT, IR
      COMMON            /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Executable Statements ..
      SLOPER = 1.0D0
      T = V
      IF (IR.EQ.0) GO TO 20
C
C     RANDOM TRANSFORMATION
      PART = 1.0D0 - ALP*(A+B)
      T = ALP*A*B + (PART+ALP*V)*V
      SLOPER = PART + 2.0D0*ALP*V
   20 IF (IT.EQ.0) GO TO 100
      IF (B.EQ.R1) GO TO 80
C
C     LEFT ENDPOINT PEAK
      RK = B - A
      W = A
   40 S = T - W
      GM = 0.0D0
      ELIM = AFLOW/DBLE(NT)
      Q = S/RK
      IF (ABS(Q).GT.EXP(ELIM)) GM = Q**NT
      X = 0.0D0
      IF (S.EQ.0.0D0) GO TO 60
      IF (ABS(GM).GT.UFLOW/ABS(S)) X = S*GM
   60 SLOPE = DBLE(NT+1)*GM*SLOPER
      GO TO 120
C
C     RIGHT ENDPOINT PEAK
   80 RK = A - B
      W = B
      GO TO 40
  100 X = T
      W = 0.0D0
      SLOPE = SLOPER
  120 VAL = SLOPE*F(X+W)
      RETURN
      END


C     ===================================================
C     =================== FUNCTION X02AMF  ==============
C     ===================================================


      DOUBLE PRECISION FUNCTION X02AMF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS THE 'SAFE RANGE' PARAMETER
C     I.E. THE SMALLEST POSITIVE MODEL NUMBER Z SUCH THAT
C     FOR ANY X WHICH SATISFIES X.GE.Z AND X.LE.1/Z
C     THE FOLLOWING CAN BE COMPUTED WITHOUT OVERFLOW, UNDERFLOW OR OTHER
C     ERROR
C
C        -X
C        1.0/X
C        SQRT(X)
C        LOG(X)
C        EXP(LOG(X))
C        Y**(LOG(X)/LOG(Y)) FOR ANY Y
C
      DOUBLE PRECISION X02CON
      DATA X02CON /2.22507385850721D-35 /
C     .. Executable Statements ..
      X02AMF = X02CON
      RETURN
      END

C     =======================================================
C     ==============FUNCTION X02AJF  ========================
C     =======================================================


      DOUBLE PRECISION FUNCTION X02AJF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS  (1/2)*B**(1-P)  IF ROUNDS IS .TRUE.
C     RETURNS  B**(1-P)  OTHERWISE
C
      DOUBLE PRECISION X02CON
      DATA X02CON /1.11130722679765D-16 /
C     .. Executable Statements ..
      X02AJF = X02CON
      RETURN
      END

C     ==============================================================
C     ============================ D01AJF ==========================
C     ==============================================================

      SUBROUTINE D01AJF(F,A,B,EPSABS,EPSREL,RESULT,ABSERR,WORK,LWORK,
     *                  IWORK,LIWORK,IFAIL)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C
C     D01AJF IS A GENERAL PURPOSE INTEGRATOR WHICH CALCULATES
C     AN APPROXIMATION TO THE INTEGRAL OF A FUNCTION OVER A FINITE
C     INTERVAL (A,B)
C
C     D01AJF ITSELF IS ESSENTIALLY A DUMMY ROUTINE WHOSE FUNCTION IS TO
C     PARTITION THE WORK ARRAYS WORK AND IWORK FOR USE BY D01AJV.
C     WORK IS PARTITIONED INTO 4 ARRAYS EACH OF SIZE LIMIT, WHERE
C     LIMIT = MIN(LWORK/4, LIWORK).
C     IWORK IS A SINGLE ARRAY IN D01AJV OF SIZE LIMIT.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO
      PARAMETER         (ZERO=0.0D0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D01AJF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, ABSERR, B, EPSABS, EPSREL
      real*8 RESULT
      INTEGER           IFAIL, LIWORK, LWORK
C     .. Array Arguments ..
      DOUBLE PRECISION  WORK(LWORK)
      INTEGER           IWORK(LIWORK)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Local Scalars ..
      INTEGER           I, IBL, IEL, IER, IERR, IRL, J, JBL, JEL, JRL,
     *                  K, LAST, LIMIT, NEVAL, NREC
      CHARACTER*1       ORDER
C     .. Local Arrays ..
      CHARACTER*80      REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          D01AJV, M01DAF, M01EAF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MIN
C     .. Executable Statements ..
      IER = IFAIL
C     CHECK THAT MINIMUM WORKSPACE REQUIREMENTS ARE MET
      IF (LWORK.LT.4 .OR. LIWORK.LT.1) GO TO 100
C     LIMIT - UPPER BOUND ON NUMBER OF SUBINTERVALS
      LIMIT = MIN(LWORK/4,LIWORK)
C     SET UP BASE ADDRESSES FOR WORK ARRAYS
      IBL = LIMIT + 1
      IEL = LIMIT + IBL
      IRL = LIMIT + IEL
C     PERFORM INTEGRATION
      CALL D01AJV(F,A,B,ABS(EPSABS),ABS(EPSREL),WORK(1),WORK(IBL),
     *            WORK(IEL),WORK(IRL),LIMIT,IWORK,LIMIT,RESULT,ABSERR,
     *            NEVAL,IER)
C     RE-ORDER THE ELEMENTS OF WORK SO THAT THE RIGHT END-POINTS OF THE
C     SUB-INTERVALS (BLIST), ABSOLUTE ERROR ESTIMATES (ELIST) AND
C     APPROXIMATIONS TO THE INTEGRAL OVER THE SUB-INTERVALS (RLIST)
C     ARE EASILY ACCESSIBLE TO THE USER (SEE D01AJV).
      LAST = IWORK(1)
      IF (IER.LT.6 .AND. LAST.GE.1) THEN
	 JBL = LAST
	 JEL = 2*LAST
	 JRL = 3*LAST
	 IF (LAST.LT.LIMIT) THEN
	    DO 20 I = 1, LAST
	       WORK(JBL+I) = WORK(IBL+I-1)
   20       CONTINUE
	    DO 40 I = 1, LAST
	       WORK(JEL+I) = WORK(IEL+I-1)
   40       CONTINUE
	    DO 60 I = 1, LAST
	       WORK(JRL+I) = WORK(IRL+I-1)
   60       CONTINUE
	 END IF
C        ZERO THE REMAINING PART OF WORK
	 K = 4*LAST + 1
	 DO 80 J = K, LWORK
	    WORK(J) = ZERO
   80    CONTINUE
C        SORT THE ELEMENTS OF ALIST INTO ASCENDING ORDER USING M01DAF
C        AND M01EAF. ON EXIT FROM M01DAF, IWORK(1), ... ,IWORK(LAST)
C        CONTAIN THE RANKS OF ALIST(1), ... ,ALIST(LAST).
	 IERR = 0
	 ORDER = 'A'
	 CALL M01DAF(WORK(1),1,LAST,ORDER,IWORK,IERR)
	 CALL M01EAF(WORK(1),1,LAST,IWORK,IERR)
C        USE IWORK(1), ... ,IWORK(LAST) TO RECOVER THE VALUES OF
C        BLIST(I), ELIST(I) AND RLIST(I) CORRESPONDING TO ALIST(I)
C        AS RETURNED BY M01EAF, WHERE I = 1, 2, ...,LAST.
	 JBL = JBL + 1
	 CALL M01EAF(WORK(JBL),1,LAST,IWORK,IERR)
	 JEL = JEL + 1
	 CALL M01EAF(WORK(JEL),1,LAST,IWORK,IERR)
	 JRL = JRL + 1
	 CALL M01EAF(WORK(JRL),1,LAST,IWORK,IERR)
	 IWORK(1) = LAST
      END IF
      IF (IER.NE.0) GO TO 120
      IFAIL = 0
      GO TO 140
C     ERROR 6 = INSUFFICIENT WORKSPACE
  100 IER = 6
      WRITE (REC,FMT=99999) LWORK, LIWORK
  120 NREC = 2
      IF (IER.EQ.1) THEN
	 WRITE (REC,FMT=99998) LIMIT, LWORK, LIWORK
      ELSE IF (IER.EQ.2) THEN
	 WRITE (REC,FMT=99997) EPSABS, EPSREL
      ELSE IF (IER.EQ.3) THEN
	 NREC = 0
      ELSE IF (IER.EQ.4) THEN
	 WRITE (REC(1),FMT=99996)
	 NREC = 1
      ELSE IF (IER.EQ.5) THEN
	 WRITE (REC(1),FMT=99995)
	 NREC = 1
      END IF
      IFAIL = P01ABF(IFAIL,IER,SRNAME,NREC,REC)
  140 RETURN
C
99999 FORMAT (' ** On entry, LW.lt.4 or LIW.lt.1:',/'    LW = ',I16,
     *       '  LIW = ',I16)
99998 FORMAT (' ** The maximum number of subdivisions (LIMIT) has been',
     *       ' reached:',/'    LIMIT = ',I16,'   LW = ',I16,'   LIW = ',
     *       I16)
99997 FORMAT (' ** Round-off error prevents the requested tolerance fr',
     *       'om being achieved:',/'    EPSABS = ',1P,D8.1,
     *       '  EPSREL = ',1P,D8.1)
99996 FORMAT (' ** Round-off error is detected in the extrapolation ta',
     *       'ble')
99995 FORMAT (' ** The integral is probably divergent or slowly conver',
     *       'gent')
      END


C     ===============================================================
C     ============================ D01AJV ===========================
C     ===============================================================

      SUBROUTINE D01AJV(F,A,B,EPSABS,EPSREL,ALIST,BLIST,ELIST,RLIST,
     *                  LIMIT,IORD,LIORD,RESULT,ABSERR,NEVAL,IER)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C     BASED ON QUADPACK ROUTINE  QAGS.
C     ..................................................................
C
C        PURPOSE
C           THE ROUTINE CALCULATES AN APPROXIMATION  RESULT  TO A GIVEN
C           DEFINITE INTEGRAL   I = INTEGRAL OF  F  OVER (A,B),
C           HOPEFULLY SATISFYING FOLLOWING CLAIM FOR ACCURACY
C           ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
C
C        PARAMETERS
C         ON ENTRY
C            F      - real*8
C                     FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
C                     FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
C                     DECLARED E X T E R N A L IN THE DRIVER PROGRAM.
C
C            A      - real*8
C                     LOWER LIMIT OF INTEGRATION
C
C            B      - real*8
C                     UPPER LIMIT OF INTEGRATION
C
C            EPSABS - real*8
C                     ABSOLUTE ACCURACY REQUESTED
C            EPSREL - real*8
C                     RELATIVE ACCURACY REQUESTED
C
C            ALIST,BLIST,ELIST,RLIST
C                   - real*8 WORK ARRAYS (FUNCTIONS DESCRIBED BELOW)
C
C            LIMIT  - INTEGER
C                     GIVES AN UPPERBOUND ON THE NUMBER OF SUBINTERVALS
C                     IN THE PARTITION OF (A,B), LIMIT.GE.1.
C
C            IORD   - INTEGER
C                     WORK ARRAY OF DIMENSION LIORD
C
C            LIORD  - INTEGER
C                     LENGTH OF IORD (=LIMIT)
C
C         ON RETURN
C            RESULT - real*8
C                     APPROXIMATION TO THE INTEGRAL
C
C            ABSERR - real*8
C                     ESTIMATE OF THE MODULUS OF THE ABSOLUTE ERROR,
C                     WHICH SHOULD EQUAL OR EXCEED ABS(I-RESULT)
C
C            NEVAL  - INTEGER
C                     NUMBER OF INTEGRAND EVALUATIONS
C
C            IER    - INTEGER
C                     IER = 0 NORMAL AND RELIABLE TERMINATION OF THE
C                             ROUTINE. IT IS ASSUMED THAT THE REQUESTED
C                             ACCURACY HAS BEEN ACHIEVED.
C                     IER.GT.0 ABNORMAL TERMINATION OF THE ROUTINE
C                             THE ESTIMATES FOR INTEGRAL AND ERROR ARE
C                             LESS RELIABLE. IT IS ASSUMED THAT THE
C                             REQUESTED ACCURACY HAS NOT BEEN ACHIEVED.
C                         = 1 MAXIMUM NUMBER OF SUBDIVISIONS ALLOWED
C                             HAS BEEN ACHIEVED. ONE CAN ALLOW MORE SUB-
C                             DIVISIONS BY INCREASING THE DATA VALUE OF
C                             LIMIT IN D01AJV (AND TAKING THE ACCORDING
C                             DIMENSION ADJUSTMENTS INTO ACCOUNT).
C                             HOWEVER, IF THIS YIELDS NO IMPROVEMENT
C                             IT IS ADVISED TO ANALYZE THE INTEGRAND
C                             IN ORDER TO DETERMINE THE INTEGRATION
C                             DIFFICULTIES. IF THE POSITION OF A
C                             LOCAL DIFFICULTY CAN BE DETERMINED (E.G.
C                             SINGULARITY, DISCONTINUITY WITHIN THE
C                             INTERVAL) ONE WILL PROBABLY GAIN FROM
C                             SPLITTING UP THE INTERVAL AT THIS POINT
C                             AND CALLING THE INTEGRATOR ON THE SUB-
C                             RANGES. IF POSSIBLE, AN APPROPRIATE
C                             SPECIAL-PURPOSE INTEGRATOR SHOULD BE USED,
C                             WHICH IS DESIGNED FOR HANDLING THE TYPE
C                             OF DIFFICULTY INVOLVED.
C                         = 2 THE OCCURRENCE OF ROUNDOFF ERROR IS DETEC-
C                             TED, WHICH PREVENTS THE REQUESTED
C                             TOLERANCE FROM BEING ACHIEVED.
C                             THE ERROR MAY BE UNDER-ESTIMATED.
C                         = 3 EXTREMELY BAD INTEGRAND BEHAVIOUR OCCURS
C                             AT SOME  POINTS OF THE INTEGRATION
C                             INTERVAL.
C                         = 4 THE ALGORITHM DOES NOT CONVERGE. ROUNDOFF
C                             ERROR IS DETECTED IN THE EXTRAPOLATION
C                             TABLE. IT IS PRESUMED THAT THE REQUESTED
C                             TOLERANCE CANNOT BE ACHIEVED, AND THAT THE
C                             RETURNED RESULT IS THE BEST WHICH CAN BE
C                             OBTAINED.
C                         = 5 THE INTEGRAL IS PROBABLY DIVERGENT, OR
C                             SLOWLY CONVERGENT. IT MUST BE NOTED THAT
C                             DIVERGENCE CAN OCCUR WITH ANY OTHER VALUE
C                             OF IER.
C     ..................................................................
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, ABSERR, B, EPSABS, EPSREL
      real*8 RESULT
      INTEGER           IER, LIMIT, LIORD, NEVAL
C     .. Array Arguments ..
      DOUBLE PRECISION  ALIST(LIMIT), BLIST(LIMIT), ELIST(LIMIT),
     *                  RLIST(LIMIT)
      INTEGER           IORD(LIORD)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Local Scalars ..
      DOUBLE PRECISION  A1, A2, ABSEPS, AREA, AREA1, AREA12, AREA2, B1,
     *                  B2, CORREC, DEFAB1, DEFAB2, DEFABS, DRES,
     *                  EPMACH, ERLARG, ERLAST, ERRBND, ERRMAX, ERRO12,
     *                  ERROR1, ERROR2, ERRSUM, ERTEST, OFLOW, RESABS,
     *                  RESEPS, SMALL, UFLOW
      INTEGER           ID, IERRO, IERS, IROFF1, IROFF2, IROFF3, JUPBND,
     *                  K, KSGN, KTMIN, LAST, MAXERR, NERR, NRES, NRMAX,
     *                  NUMRL2
      LOGICAL           EXTRAP, NOEXT
C     .. Local Arrays ..
      DOUBLE PRECISION  RES3LA(3), RLIST2(52)
      CHARACTER*80      REC(2)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. External Subroutines ..
      EXTERNAL          D01AJX, D01AJY, D01AJZ, X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX
C     .. Executable Statements ..
C
C            THE DIMENSION OF RLIST2 IS DETERMINED BY THE VALUE OF
C            LIMEXP IN SUBROUTINE D01AJY (RLIST2 SHOULD BE OF DIMENSION
C            (LIMEXP+2) AT LEAST).
C
C            LIST OF MAJOR VARIABLES
C            -----------------------
C
C           ALIST     - LIST OF LEFT END POINTS OF ALL SUBINTERVALS
C                       CONSIDERED UP TO NOW
C           BLIST     - LIST OF RIGHT END POINTS OF ALL SUBINTERVALS
C                       CONSIDERED UP TO NOW
C           RLIST(I)  - APPROXIMATION TO THE INTEGRAL OVER
C                       (ALIST(I),BLIST(I))
C           RLIST2    - ARRAY OF DIMENSION AT LEAST LIMEXP+2 CONTAINING
C                       THE PART OF THE EPSILON TABLE WHICH IS STILL
C                       NEEDED FOR FURTHER COMPUTATIONS
C           ELIST(I)  - ERROR ESTIMATE APPLYING TO RLIST(I)
C           MAXERR    - POINTER TO THE INTERVAL WITH LARGEST ERROR
C                       ESTIMATE
C           ERRMAX    - ELIST(MAXERR)
C           ERLAST    - ERROR ON THE INTERVAL CURRENTLY SUBDIVIDED
C                       (BEFORE THAT SUBDIVISION HAS TAKEN PLACE)
C           AREA      - SUM OF THE INTEGRALS OVER THE SUBINTERVALS
C           ERRSUM    - SUM OF THE ERRORS OVER THE SUBINTERVALS
C           ERRBND    - REQUESTED ACCURACY MAX(EPSABS,EPSREL*
C                       ABS(RESULT))
C           *****1    - VARIABLE FOR THE LEFT INTERVAL
C           *****2    - VARIABLE FOR THE RIGHT INTERVAL
C           LAST      - INDEX FOR SUBDIVISION
C           NRES      - NUMBER OF CALLS TO THE EXTRAPOLATION ROUTINE
C           NUMRL2    - NUMBER OF ELEMENTS CURRENTLY IN RLIST2. IF AN
C                       APPROPRIATE APPROXIMATION TO THE COMPOUNDED
C                       INTEGRAL HAS BEEN OBTAINED IT IS PUT IN
C                       RLIST2(NUMRL2) AFTER NUMRL2 HAS BEEN INCREASED
C                       BY ONE.
C           SMALL     - LENGTH OF THE SMALLEST INTERVAL CONSIDERED
C                       UP TO NOW, MULTIPLIED BY 1.5
C           ERLARG    - SUM OF THE ERRORS OVER THE INTERVALS LARGER
C                       THAN THE SMALLEST INTERVAL CONSIDERED UP TO NOW
C           EXTRAP    - LOGICAL VARIABLE DENOTING THAT THE ROUTINE IS
C                       ATTEMPTING TO PERFORM EXTRAPOLATION I.E. BEFORE
C                       SUBDIVIDING THE SMALLEST INTERVAL WE TRY TO
C                       DECREASE THE VALUE OF ERLARG.
C           NOEXT     - LOGICAL VARIABLE DENOTING THAT EXTRAPOLATION
C                       IS NO LONGER ALLOWED (TRUE VALUE)
C
      EPMACH = X02AJF()
      UFLOW = X02AMF()
      OFLOW = 1.0D+00/UFLOW
C
C            TEST ON VALIDITY OF PARAMETERS
C            ------------------------------
      IERS = IER
      IER = 0
      NEVAL = 0
      LAST = 0
      RESULT = 0.0D+00
      ABSERR = 0.0D+00
      ALIST(1) = A
      BLIST(1) = B
      RLIST(1) = 0.0D+00
      ELIST(1) = 0.0D+00
C
C           FIRST APPROXIMATION TO THE INTEGRAL
C           -----------------------------------
C
      IERRO = 0
      CALL D01AJZ(F,A,B,RESULT,ABSERR,DEFABS,RESABS)
C
C           TEST ON ACCURACY.
C
      DRES = ABS(RESULT)
      ERRBND = MAX(EPSABS,EPSREL*DRES)
      LAST = 1
      RLIST(1) = RESULT
      ELIST(1) = ABSERR
      IORD(1) = 1
      IF ((ABSERR.LE.ERRBND .AND. ABSERR.NE.RESABS)
     *    .OR. ABSERR.EQ.0.0D+00) GO TO 340
      IF (LIMIT.EQ.1) IER = 1
      IF (ABSERR.LE.1.0D+02*EPMACH*DEFABS .AND. ABSERR.GT.ERRBND)
     *    IER = 2
      IF (IER.NE.0) GO TO 340
C
C           INITIALIZATION
C           --------------
C
      RLIST2(1) = RESULT
      ERRMAX = ABSERR
      MAXERR = 1
      AREA = RESULT
      ERRSUM = ABSERR
      ABSERR = OFLOW
      NRMAX = 1
      NRES = 0
      NUMRL2 = 2
      KTMIN = 0
      EXTRAP = .FALSE.
      NOEXT = .FALSE.
      IROFF1 = 0
      IROFF2 = 0
      IROFF3 = 0
      KSGN = -1
      IF (DRES.GE.(1.0D+00-5.0D+01*EPMACH)*DEFABS) KSGN = 1
C
C           MAIN DO-LOOP
C           ------------
C
      DO 200 LAST = 2, LIMIT
C
C           BISECT THE SUBINTERVAL WITH THE NRMAX-TH LARGEST ERROR
C           ESTIMATE.
C
	 A1 = ALIST(MAXERR)
	 B1 = 5.0D-01*(ALIST(MAXERR)+BLIST(MAXERR))
	 A2 = B1
	 B2 = BLIST(MAXERR)
	 ERLAST = ERRMAX
	 CALL D01AJZ(F,A1,B1,AREA1,ERROR1,RESABS,DEFAB1)
	 CALL D01AJZ(F,A2,B2,AREA2,ERROR2,RESABS,DEFAB2)
C
C           IMPROVE PREVIOUS APPROXIMATIONS TO INTEGRAL AND ERROR
C           AND TEST FOR ACCURACY.
C
	 AREA12 = AREA1 + AREA2
	 ERRO12 = ERROR1 + ERROR2
	 ERRSUM = ERRSUM + ERRO12 - ERRMAX
	 AREA = AREA + AREA12 - RLIST(MAXERR)
	 IF (DEFAB1.EQ.ERROR1 .OR. DEFAB2.EQ.ERROR2) GO TO 40
	 IF (ABS(RLIST(MAXERR)-AREA12).GT.1.0D-05*ABS(AREA12)
     *       .OR. ERRO12.LT.9.9D-01*ERRMAX) GO TO 20
	 IF (EXTRAP) IROFF2 = IROFF2 + 1
	 IF ( .NOT. EXTRAP) IROFF1 = IROFF1 + 1
   20    IF (LAST.GT.10 .AND. ERRO12.GT.ERRMAX) IROFF3 = IROFF3 + 1
   40    RLIST(MAXERR) = AREA1
	 RLIST(LAST) = AREA2
	 ERRBND = MAX(EPSABS,EPSREL*ABS(AREA))
C
C           APPEND THE NEWLY-CREATED INTERVALS TO THE LIST.
C
	 IF (ERROR2.GT.ERROR1) GO TO 60
	 ALIST(LAST) = A2
	 BLIST(MAXERR) = B1
	 BLIST(LAST) = B2
	 ELIST(MAXERR) = ERROR1
	 ELIST(LAST) = ERROR2
	 GO TO 80
   60    ALIST(MAXERR) = A2
	 ALIST(LAST) = A1
	 BLIST(LAST) = B1
	 RLIST(MAXERR) = AREA2
	 RLIST(LAST) = AREA1
	 ELIST(MAXERR) = ERROR2
	 ELIST(LAST) = ERROR1
C
C           CALL SUBROUTINE D01AJX TO MAINTAIN THE DESCENDING ORDERING
C           IN THE LIST OF ERROR ESTIMATES AND SELECT THE SUBINTERVAL
C           WITH NRMAX-TH LARGEST ERROR ESTIMATE (TO BE BISECTED NEXT).
C
   80    CALL D01AJX(LIMIT,LAST,MAXERR,ERRMAX,ELIST,IORD,NRMAX)
C        ***JUMP OUT OF DO-LOOP
	 IF (ERRSUM.LE.ERRBND) GO TO 280
C
C           SET ERROR FLAG IN THE CASE THAT THE NUMBER OF SUBINTERVALS
C           EQUALS LIMIT.
C
	 IF (LAST.EQ.LIMIT) IER = 1
C
C           TEST FOR ROUNDOFF ERROR AND EVENTUALLY SET ERROR FLAG.
C
	 IF (IROFF1+IROFF2.GE.10 .OR. IROFF3.GE.20) IER = 2
	 IF (IROFF2.GE.5) IERRO = 3
C
C           SET ERROR FLAG IN THE CASE OF BAD INTEGRAND BEHAVIOUR
C           AT A POINT OF THE INTEGRATION RANGE.
C
	 IF (MAX(ABS(A1),ABS(B2)).LE.(1.0D+00+1.0D+03*EPMACH)*(ABS(A2)
     *       +1.0D+03*UFLOW)) IER = 4
C        ***JUMP OUT OF DO-LOOP
	 IF (IER.GT.1) GO TO 220
	 IF (LAST.EQ.2) GO TO 180
	 IF (NOEXT) GO TO 200
	 ERLARG = ERLARG - ERLAST
	 IF (ABS(B1-A1).GT.SMALL) ERLARG = ERLARG + ERRO12
	 IF (EXTRAP) GO TO 100
C
C           TEST WHETHER THE INTERVAL TO BE BISECTED NEXT IS THE
C           SMALLEST INTERVAL.
C
	 IF (ABS(BLIST(MAXERR)-ALIST(MAXERR)).GT.SMALL) GO TO 200
	 EXTRAP = .TRUE.
	 NRMAX = 2
  100    IF (IERRO.EQ.3 .OR. ERLARG.LE.ERTEST) GO TO 140
C
C           THE SMALLEST INTERVAL HAS THE LARGEST ERROR.
C           BEFORE BISECTING DECREASE THE SUM OF THE ERRORS OVER THE
C           LARGER INTERVALS (ERLARG) AND PERFORM EXTRAPOLATION.
C
	 ID = NRMAX
	 JUPBND = LAST
	 IF (LAST.GT.(2+LIMIT/2)) JUPBND = LIMIT + 3 - LAST
	 DO 120 K = ID, JUPBND
	    MAXERR = IORD(NRMAX)
	    ERRMAX = ELIST(MAXERR)
C           ***JUMP OUT OF DO-LOOP
	    IF (ABS(BLIST(MAXERR)-ALIST(MAXERR)).GT.SMALL) GO TO 200
	    NRMAX = NRMAX + 1
  120    CONTINUE
C
C           PERFORM EXTRAPOLATION.
C
  140    NUMRL2 = NUMRL2 + 1
	 RLIST2(NUMRL2) = AREA
	 CALL D01AJY(NUMRL2,RLIST2,RESEPS,ABSEPS,RES3LA,NRES)
	 KTMIN = KTMIN + 1
	 IF (KTMIN.GT.5 .AND. ABSERR.LT.1.0D-03*ERRSUM) IER = 5
	 IF (ABSEPS.GE.ABSERR) GO TO 160
	 KTMIN = 0
	 ABSERR = ABSEPS
	 RESULT = RESEPS
	 CORREC = ERLARG
	 ERTEST = MAX(EPSABS,EPSREL*ABS(RESEPS))
C        ***JUMP OUT OF DO-LOOP
	 IF (ABSERR.LE.ERTEST) THEN
	    IF (IER.EQ.1) IER = 0
	    GO TO 220
	 END IF
C
C           PREPARE BISECTION OF THE SMALLEST INTERVAL.
C
  160    IF (NUMRL2.EQ.1) NOEXT = .TRUE.
	 IF (IER.EQ.5 .OR. IER.EQ.1) GO TO 220
	 MAXERR = IORD(1)
	 ERRMAX = ELIST(MAXERR)
	 NRMAX = 1
	 EXTRAP = .FALSE.
	 SMALL = SMALL*5.0D-01
	 ERLARG = ERRSUM
	 GO TO 200
  180    SMALL = ABS(B-A)*3.75D-01
	 ERLARG = ERRSUM
	 ERTEST = ERRBND
	 RLIST2(2) = AREA
  200 CONTINUE
      LAST = LIMIT
C
C           SET FINAL RESULT AND ERROR ESTIMATE.
C           ------------------------------------
C
  220 IF (ABSERR.EQ.OFLOW) GO TO 280
      IF (IER+IERRO.EQ.0) GO TO 260
      IF (IERRO.EQ.3) ABSERR = ABSERR + CORREC
      IF (IER.EQ.0) IER = 3
      IF (RESULT.NE.0.0D+00 .AND. AREA.NE.0.0D+00) GO TO 240
      IF (ABSERR.GT.ERRSUM) GO TO 280
      IF (AREA.EQ.0.0D+00) GO TO 320
      GO TO 260
  240 IF (ABSERR/ABS(RESULT).GT.ERRSUM/ABS(AREA)) GO TO 280
C
C           TEST ON DIVERGENCE.
C
  260 IF (KSGN.EQ.(-1) .AND. MAX(ABS(RESULT),ABS(AREA))
     *    .LE.DEFABS*1.0D-02) GO TO 320
      IF (1.0D-02.GT.(RESULT/AREA) .OR. (RESULT/AREA)
     *    .GT.1.0D+02 .OR. ERRSUM.GT.ABS(AREA)) IER = 6
      GO TO 320
C
C           COMPUTE GLOBAL INTEGRAL SUM.
C
  280 RESULT = 0.0D+00
      DO 300 K = 1, LAST
	 RESULT = RESULT + RLIST(K)
  300 CONTINUE
      ABSERR = ERRSUM
  320 IF (IER.GT.2) IER = IER - 1
  340 NEVAL = 42*LAST - 21
      IORD(1) = LAST
      IF (IER.EQ.3 .AND. IERS.NE.1) THEN
	 CALL X04AAF(0,NERR)
	 WRITE (REC,FMT=99999) A1, B2
	 CALL X04BAF(NERR,REC(1))
	 CALL X04BAF(NERR,REC(2))
      END IF
      RETURN
C
99999 FORMAT (' ** Extremely bad integrand behaviour occurs around the',
     *       ' subinterval',/'    (',1P,D15.7,' , ',1P,D15.7,' )')
      END

C     ==========================================================
C     ========================== D01AJZ ========================
C     ==========================================================

      SUBROUTINE D01AJZ(F,A,B,RESULT,ABSERR,RESABS,RESASC)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C     BASED ON QUADPACK ROUTINE  QK21.
C     ..................................................................
C
C           PURPOSE
C              TO COMPUTE I = INTEGRAL OF F OVER (A,B), WITH ERROR
C                             ESTIMATE
C                         J = INTEGRAL OF ABS(F) OVER (A,B)
C
C           PARAMETERS
C            ON ENTRY
C              F      - real*8
C                       FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
C                       FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
C                       DECLARED E X T E R N A L IN THE CALLING PROGRAM.
C
C              A      - real*8
C                       LOWER LIMIT OF INTEGRATION
C
C              B      - real*8
C                       UPPER LIMIT OF INTEGRATION
C
C            ON RETURN
C              RESULT - real*8
C                       APPROXIMATION TO THE INTEGRAL I
C                       RESULT IS COMPUTED BY APPLYING THE 21-POINT
C                       KRONROD RULE (RESK) OBTAINED BY OPTIMAL ADDITION
C                       OF ABSCISSAE TO THE 10-POINT GAUSS RULE (RESG).
C
C              ABSERR - real*8
C                       ESTIMATE OF THE MODULUS OF THE ABSOLUTE ERROR,
C                       WHICH SHOULD NOT EXCEED ABS(I-RESULT)
C
C              RESABS - real*8
C                       APPROXIMATION TO THE INTEGRAL J
C
C              RESASC - real*8
C                       APPROXIMATION TO THE INTEGRAL OF ABS(F-I/(B-A))
C                       OVER (A,B)
C
C     ..................................................................
C
C           THE ABSCISSAE AND WEIGHTS ARE GIVEN FOR THE INTERVAL (-1,1).
C           BECAUSE OF SYMMETRY ONLY THE POSITIVE ABSCISSAE AND THEIR
C           CORRESPONDING WEIGHTS ARE GIVEN.
C
C           XGK    - ABSCISSAE OF THE 21-POINT KRONROD RULE
C                    XGK(2), XGK(4), ...  ABSCISSAE OF THE 10-POINT
C                    GAUSS RULE
C                    XGK(1), XGK(3), ...  ABSCISSAE WHICH ARE OPTIMALLY
C                    ADDED TO THE 10-POINT GAUSS RULE
C
C           WGK    - WEIGHTS OF THE 21-POINT KRONROD RULE
C
C           WG     - WEIGHTS OF THE 10-POINT GAUSS RULE
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, ABSERR, B, RESABS, RESASC, RESULT
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSC, CENTR, DHLGTH, EPMACH, FC, FSUM, FVAL1,
     *                  FVAL2, HLGTH, OFLOW, RESG, RESK, RESKH, UFLOW
      INTEGER           J, JTW, JTWM1
C     .. Local Arrays ..
      DOUBLE PRECISION  FV1(10), FV2(10), WG(5), WGK(11), XGK(11)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN
C     .. Data statements ..
      DATA              WG(1)/0.066671344308688137593568809893332D+00/,
     *                  WG(2)/0.149451349150580593145776339657697D+00/,
     *                  WG(3)/0.219086362515982043995534934228163D+00/,
     *                  WG(4)/0.269266719309996355091226921569469D+00/,
     *                  WG(5)/0.295524224714752870173892994651338D+00/
      DATA              XGK(1)/0.995657163025808080735527280689003D+00/,
     *                  XGK(2)/0.973906528517171720077964012084452D+00/,
     *                  XGK(3)/0.930157491355708226001207180059508D+00/,
     *                  XGK(4)/0.865063366688984510732096688423493D+00/,
     *                  XGK(5)/0.780817726586416897063717578345042D+00/,
     *                  XGK(6)/0.679409568299024406234327365114874D+00/,
     *                  XGK(7)/0.562757134668604683339000099272694D+00/,
     *                  XGK(8)/0.433395394129247190799265943165784D+00/,
     *                  XGK(9)/0.294392862701460198131126603103866D+00/,
     *                  XGK(10)/0.148874338981631210884826001129720D+00/
     *                  , XGK(11)/
     *                  0.000000000000000000000000000000000D+00/
      DATA              WGK(1)/0.011694638867371874278064396062192D+00/,
     *                  WGK(2)/0.032558162307964727478818972459390D+00/,
     *                  WGK(3)/0.054755896574351996031381300244580D+00/,
     *                  WGK(4)/0.075039674810919952767043140916190D+00/,
     *                  WGK(5)/0.093125454583697605535065465083366D+00/,
     *                  WGK(6)/0.109387158802297641899210590325805D+00/,
     *                  WGK(7)/0.123491976262065851077958109831074D+00/,
     *                  WGK(8)/0.134709217311473325928054001771707D+00/,
     *                  WGK(9)/0.142775938577060080797094273138717D+00/,
     *                  WGK(10)/0.147739104901338491374841515972068D+00/
     *                  , WGK(11)/
     *                  0.149445554002916905664936468389821D+00/
C     .. Executable Statements ..
C
C
C           LIST OF MAJOR VARIABLES
C           -----------------------
C
C           CENTR  - MID POINT OF THE INTERVAL
C           HLGTH  - HALF-LENGTH OF THE INTERVAL
C           ABSC   - ABSCISSA
C           FVAL*  - FUNCTION VALUE
C           RESG   - RESULT OF THE 10-POINT GAUSS FORMULA
C           RESK   - RESULT OF THE 21-POINT KRONROD FORMULA
C           RESKH  - APPROXIMATION TO THE MEAN VALUE OF F OVER (A,B),
C                    I.E. TO I/(B-A)
C
      EPMACH = X02AJF()
      UFLOW = X02AMF()
      OFLOW = 1.0D+00/UFLOW
      CENTR = 5.0D-01*(A+B)
      HLGTH = 5.0D-01*(B-A)
      DHLGTH = ABS(HLGTH)
C
C           COMPUTE THE 21-POINT KRONROD APPROXIMATION TO THE
C           INTEGRAL, AND ESTIMATE THE ABSOLUTE ERROR.
C
      RESG = 0.0D+00
      FC = F(CENTR)
      RESK = WGK(11)*FC
      RESABS = ABS(RESK)
      DO 20 J = 1, 5
	 JTW = 2*J
	 ABSC = HLGTH*XGK(JTW)
	 FVAL1 = F(CENTR-ABSC)
	 FVAL2 = F(CENTR+ABSC)
	 FV1(JTW) = FVAL1
	 FV2(JTW) = FVAL2
	 FSUM = FVAL1 + FVAL2
	 RESG = RESG + WG(J)*FSUM
	 RESK = RESK + WGK(JTW)*FSUM
	 RESABS = RESABS + WGK(JTW)*(ABS(FVAL1)+ABS(FVAL2))
   20 CONTINUE
      DO 40 J = 1, 5
	 JTWM1 = 2*J - 1
	 ABSC = HLGTH*XGK(JTWM1)
	 FVAL1 = F(CENTR-ABSC)
	 FVAL2 = F(CENTR+ABSC)
	 FV1(JTWM1) = FVAL1
	 FV2(JTWM1) = FVAL2
	 FSUM = FVAL1 + FVAL2
	 RESK = RESK + WGK(JTWM1)*FSUM
	 RESABS = RESABS + WGK(JTWM1)*(ABS(FVAL1)+ABS(FVAL2))
   40 CONTINUE
      RESKH = RESK*5.0D-01
      RESASC = WGK(11)*ABS(FC-RESKH)
      DO 60 J = 1, 10
	 RESASC = RESASC + WGK(J)*(ABS(FV1(J)-RESKH)+ABS(FV2(J)-RESKH))
   60 CONTINUE
      RESULT = RESK*HLGTH
      RESABS = RESABS*DHLGTH
      RESASC = RESASC*DHLGTH
      ABSERR = ABS((RESK-RESG)*HLGTH)
      IF (RESASC.NE.0.0D+00 .AND. ABSERR.NE.0.0D+00)
     *    ABSERR = RESASC*MIN(1.0D+00,(2.0D+02*ABSERR/RESASC)**1.5D+00)
      IF (RESABS.GT.UFLOW/(5.0D+01*EPMACH))
     *    ABSERR = MAX((EPMACH*5.0D+01)*RESABS,ABSERR)
      RETURN
      END

C     ==========================================================
C     ====================== X04BAF ============================
C     ==========================================================

      SUBROUTINE X04BAF(NOUT,REC)
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C
C     X04BAF writes the contents of REC to the unit defined by NOUT.
C
C     Trailing blanks are not output, except that if REC is entirely
C     blank, a single blank character is output.
C     If NOUT.lt.0, i.e. if NOUT is not a valid Fortran unit identifier,
C     then no output occurs.
C
C     .. Scalar Arguments ..
      INTEGER           NOUT
      CHARACTER*(*)     REC
C     .. Local Scalars ..
      INTEGER           I
C     .. Intrinsic Functions ..
      INTRINSIC         LEN
C     .. Executable Statements ..
      IF (NOUT.GE.0) THEN
C        Remove trailing blanks
	 DO 20 I = LEN(REC), 2, -1
	    IF (REC(I:I).NE.' ') GO TO 40
   20    CONTINUE
C        Write record to external file
   40    WRITE (NOUT,FMT=99999) REC(1:I)
      END IF
      RETURN
C
99999 FORMAT (A)
      END


C     ===========================================================
C     ========================== X04AAF =========================
C     ===========================================================

      SUBROUTINE X04AAF(I,NERR)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978
C     MARK 7C REVISED IER-190 (MAY 1979)
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 14 REVISED. IER-829 (DEC 1989).
C     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER
C     (STORED IN NERR1).
C     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO
C     VALUE SPECIFIED BY NERR.
C
C     .. Scalar Arguments ..
      INTEGER           I, NERR
C     .. Local Scalars ..
      INTEGER           NERR1
C     .. Save statement ..
      SAVE              NERR1
C     .. Data statements ..
      DATA              NERR1/6/
C     .. Executable Statements ..
      IF (I.EQ.0) NERR = NERR1
      IF (I.EQ.1) NERR1 = NERR
      RETURN
      END


c     =================================================================
C     ========================= D01AJY ================================
C     =================================================================


      SUBROUTINE D01AJY(N,EPSTAB,RESULT,ABSERR,RES3LA,NRES)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C     BASED ON QUADPACK ROUTINE  QEXT.
C     ................................................................
C
C           PURPOSE
C              THE ROUTINE DETERMINES THE LIMIT OF A GIVEN SEQUENCE OF
C              APPROXIMATIONS, BY MEANS OF THE EPSILON ALGORITHM
C              OF P. WYNN.
C              AN ESTIMATE OF THE ABSOLUTE ERROR IS ALSO GIVEN.
C              THE CONDENSED EPSILON TABLE IS COMPUTED. ONLY THOSE
C              ELEMENTS NEEDED FOR THE COMPUTATION OF THE NEXT DIAGONAL
C              ARE PRESERVED.
C
C           PARAMETERS
C              N      - INTEGER
C                       EPSTAB(N) CONTAINS THE NEW ELEMENT IN THE
C                       FIRST COLUMN OF THE EPSILON TABLE.
C
C              EPSTAB - real*8
C                       VECTOR OF DIMENSION 52 CONTAINING THE ELEMENTS
C                       OF THE TWO LOWER DIAGONALS OF THE TRIANGULAR
C                       EPSILON TABLE
C                       THE ELEMENTS ARE NUMBERED STARTING AT THE
C                       RIGHT-HAND CORNER OF THE TRIANGLE.
C
C              RESULT - real*8
C                       RESULTING APPROXIMATION TO THE INTEGRAL
C
C              ABSERR - real*8
C                       ESTIMATE OF THE ABSOLUTE ERROR COMPUTED FROM
C                       RESULT AND THE 3 PREVIOUS RESULTS
C
C              RES3LA - real*8
C                       VECTOR OF DIMENSION 3 CONTAINING THE LAST 3
C                       RESULTS
C
C              NRES   - INTEGER
C                       NUMBER OF CALLS TO THE ROUTINE
C                       (SHOULD BE ZERO AT FIRST CALL)
C
C     ..................................................................
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  ABSERR, RESULT
      INTEGER           N, NRES
C     .. Array Arguments ..
      DOUBLE PRECISION  EPSTAB(52), RES3LA(3)
C     .. Local Scalars ..
      DOUBLE PRECISION  DELTA1, DELTA2, DELTA3, E0, E1, E1ABS, E2, E3,
     *                  EPMACH, EPSINF, ERR1, ERR2, ERR3, ERROR, OFLOW,
     *                  RES, SS, TOL1, TOL2, TOL3, UFLOW
      INTEGER           I, IB, IB2, IE, INDX, K1, K2, K3, LIMEXP,
     *                  NEWELM, NUM
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX
C     .. Executable Statements ..
C
C           LIST OF MAJOR VARIABLES
C           -----------------------
C
C           E0     - THE 4 ELEMENTS ON WHICH THE
C           E1       COMPUTATION OF A NEW ELEMENT IN
C           E2       THE EPSILON TABLE IS BASED
C           E3                 E0
C                        E3    E1    NEW
C                              E2
C           NEWELM - NUMBER OF ELEMENTS TO BE COMPUTED IN THE NEW
C                    DIAGONAL
C           ERROR  - ERROR = ABS(E1-E0)+ABS(E2-E1)+ABS(NEW-E2)
C           RESULT - THE ELEMENT IN THE NEW DIAGONAL WITH LEAST VALUE
C                    OF ERROR
C
C           LIMEXP IS THE MAXIMUM NUMBER OF ELEMENTS THE EPSILON TABLE
C           CAN CONTAIN. IF THIS NUMBER IS REACHED, THE UPPER DIAGONAL
C           OF THE EPSILON TABLE IS DELETED.
C
      EPMACH = X02AJF()
      UFLOW = X02AMF()
      OFLOW = 1.0D+00/UFLOW
      NRES = NRES + 1
      ABSERR = OFLOW
      RESULT = EPSTAB(N)
      IF (N.LT.3) GO TO 200
      LIMEXP = 50
      EPSTAB(N+2) = EPSTAB(N)
      NEWELM = (N-1)/2
      EPSTAB(N) = OFLOW
      NUM = N
      K1 = N
      DO 80 I = 1, NEWELM
	 K2 = K1 - 1
	 K3 = K1 - 2
	 RES = EPSTAB(K1+2)
	 E0 = EPSTAB(K3)
	 E1 = EPSTAB(K2)
	 E2 = RES
	 E1ABS = ABS(E1)
	 DELTA2 = E2 - E1
	 ERR2 = ABS(DELTA2)
	 TOL2 = MAX(ABS(E2),E1ABS)*EPMACH
	 DELTA3 = E1 - E0
	 ERR3 = ABS(DELTA3)
	 TOL3 = MAX(E1ABS,ABS(E0))*EPMACH
	 IF (ERR2.GT.TOL2 .OR. ERR3.GT.TOL3) GO TO 20
C
C           IF E0, E1 AND E2 ARE EQUAL TO WITHIN MACHINE ACCURACY,
C           CONVERGENCE IS ASSUMED.
C           RESULT = E2
C           ABSERR = ABS(E1-E0)+ABS(E2-E1)
C
	 RESULT = RES
	 ABSERR = ERR2 + ERR3
C        ***JUMP OUT OF DO-LOOP
	 GO TO 200
   20    E3 = EPSTAB(K1)
	 EPSTAB(K1) = E1
	 DELTA1 = E1 - E3
	 ERR1 = ABS(DELTA1)
	 TOL1 = MAX(E1ABS,ABS(E3))*EPMACH
C
C           IF TWO ELEMENTS ARE VERY CLOSE TO EACH OTHER, OMIT A PART
C           OF THE TABLE BY ADJUSTING THE VALUE OF N
C
	 IF (ERR1.LE.TOL1 .OR. ERR2.LE.TOL2 .OR. ERR3.LE.TOL3)
     *       GO TO 40
	 SS = 1.0D+00/DELTA1 + 1.0D+00/DELTA2 - 1.0D+00/DELTA3
	 EPSINF = ABS(SS*E1)
C
C           TEST TO DETECT IRREGULAR BEHAVIOUR IN THE TABLE, AND
C           EVENTUALLY OMIT A PART OF THE TABLE ADJUSTING THE VALUE
C           OF N.
C
	 IF (EPSINF.GT.1.0D-04) GO TO 60
   40    N = I + I - 1
C        ***JUMP OUT OF DO-LOOP
	 GO TO 100
C
C           COMPUTE A NEW ELEMENT AND EVENTUALLY ADJUST THE VALUE OF
C           RESULT.
C
   60    RES = E1 + 1.0D+00/SS
	 EPSTAB(K1) = RES
	 K1 = K1 - 2
	 ERROR = ERR2 + ABS(RES-E2) + ERR3
	 IF (ERROR.GT.ABSERR) GO TO 80
	 ABSERR = ERROR
	 RESULT = RES
   80 CONTINUE
C
C           SHIFT THE TABLE.
C
  100 IF (N.EQ.LIMEXP) N = 2*(LIMEXP/2) - 1
      IB = 1
      IF ((NUM/2)*2.EQ.NUM) IB = 2
      IE = NEWELM + 1
      DO 120 I = 1, IE
	 IB2 = IB + 2
	 EPSTAB(IB) = EPSTAB(IB2)
	 IB = IB2
  120 CONTINUE
      IF (NUM.EQ.N) GO TO 160
      INDX = NUM - N + 1
      DO 140 I = 1, N
	 EPSTAB(I) = EPSTAB(INDX)
	 INDX = INDX + 1
  140 CONTINUE
  160 IF (NRES.GE.4) GO TO 180
      RES3LA(NRES) = RESULT
      ABSERR = OFLOW
      GO TO 200
C
C           COMPUTE ERROR ESTIMATE
C
  180 ABSERR = ABS(RESULT-RES3LA(3)) + ABS(RESULT-RES3LA(2)) +
     *         ABS(RESULT-RES3LA(1))
      RES3LA(1) = RES3LA(2)
      RES3LA(2) = RES3LA(3)
      RES3LA(3) = RESULT
  200 ABSERR = MAX(ABSERR,0.5D+00*EPMACH*ABS(RESULT))
      RETURN
      END

C     =========================================================
C     ============================= M01DAF ====================
C     =========================================================

      SUBROUTINE M01DAF(RV,M1,M2,ORDER,IRANK,IFAIL)
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     M01DAF RANKS A VECTOR OF real*8 NUMBERS IN ASCENDING
C     OR DESCENDING ORDER.
C
C     M01DAF USES A VARIANT OF LIST-MERGING, AS DESCRIBED
C     BY KNUTH. THE ROUTINE TAKES ADVANTAGE OF NATURAL
C     ORDERING IN THE DATA, AND USES A SIMPLE LIST INSERTION
C     IN A PREPARATORY PASS TO GENERATE ORDERED LISTS OF
C     LENGTH AT LEAST 10. THE RANKING IS STABLE: EQUAL ELEMENTS
C     PRESERVE THEIR ORDERING IN THE INPUT DATA.
C
C     THE MINIMUM LENGTH OF THE LISTS AT THE END OF THE
C     PREPARATORY PASS IS DEFINED BY THE VARIABLE MAXINS.
C
C     WRITTEN BY N.M.MACLAREN, UNIVERSITY OF CAMBRIDGE.
C     REVISED BY NAG CENTRAL OFFICE.
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='M01DAF')
      INTEGER           MAXINS
      PARAMETER         (MAXINS=10)
C     .. Scalar Arguments ..
      INTEGER           IFAIL, M1, M2
      CHARACTER*1       ORDER
C     .. Array Arguments ..
      DOUBLE PRECISION  RV(M2)
      INTEGER           IRANK(M2)
C     .. Local Scalars ..
      DOUBLE PRECISION  A, B, C
      INTEGER           I, I1, I2, IERR, ILIST, J, J1, J2, K, K1, K2, L,
     *                  LIST1, LIST2, NLAST, NPREV, NREC
C     .. Local Arrays ..
      CHARACTER*80      P01REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. Executable Statements ..
C
C       CHECK THE ARGUMENTS AND DEAL WITH THE TRIVIAL CASE.
C
      IF (M2.LT.1 .OR. M1.LT.1 .OR. M1.GT.M2) THEN
	 IERR = 1
	 WRITE (P01REC,FMT=99999) M1, M2
	 NREC = 2
      ELSE IF (ORDER.NE.'A' .AND. ORDER.NE.'a' .AND. ORDER.NE.'D' .AND.
     *         ORDER.NE.'d') THEN
	 IERR = 2
	 WRITE (P01REC,FMT=99998) ORDER
	 NREC = 1
      ELSE IF (M1.EQ.M2) THEN
	 IRANK(M2) = M2
	 IERR = 0
      ELSE
	 IERR = 0
C
C        INITIALISE, USING NATURAL RUNS IN BOTH DIRECTIONS AND
C        STRAIGHT LIST INSERTION FOR SMALL LISTS.
C
C        I  POINTS TO THE SMALLEST ELEMENT IN THE CURRENT LIST
C        J  POINTS TO THE LARGEST  ELEMENT IN THE CURRENT LIST
C        B  IS THE VALUE OF THE SMALLEST ELEMENT IN CURRENT LIST
C        C  IS THE VALUE OF THE LARGEST  ELEMENT IN CURRENT LIST
C
	 ILIST = -1
	 K = M1
	 I = K
	 J = K
	 L = K + MAXINS
	 B = RV(K)
	 C = B
	 DO 40 K = M1 + 1, M2
C
C           DEAL WITH ADDITIONS AT EITHER END.
C
	    A = RV(K)
	    IF (A.GE.C) THEN
	       IRANK(J) = K
	       J = K
	       C = A
	    ELSE IF (A.LT.B) THEN
	       IRANK(K) = I
	       I = K
	       B = A
	    ELSE
C
C              DO AN ASCENDING LIST INSERTION.
C
	       IF (K.LT.L) THEN
		  I2 = I
   20             I1 = I2
		  I2 = IRANK(I1)
		  IF (A.GE.RV(I2)) GO TO 20
		  IRANK(I1) = K
		  IRANK(K) = I2
	       ELSE
C
C                 ADD THE CURRENT LIST ON TO THE OTHERS.
C
		  IF (ILIST.LT.0) THEN
		     LIST1 = -I
		     ILIST = 0
		  ELSE IF (ILIST.EQ.0) THEN
		     LIST2 = -I
		     ILIST = 1
		     NPREV = NLAST
		  ELSE
		     IRANK(NPREV) = -I
		     NPREV = NLAST
		  END IF
C
		  NLAST = J
		  I = K
		  J = K
		  L = K + MAXINS
		  B = RV(K)
		  C = B
	       END IF
	    END IF
   40    CONTINUE
C
C        TIDY UP AT THE END.
C
	 IRANK(J) = 0
	 IF (ILIST.LT.0) THEN
	    LIST1 = -I
	    GO TO 280
	 ELSE IF (ILIST.EQ.0) THEN
	    LIST2 = -I
	 ELSE
	    IRANK(NPREV) = -I
	 END IF
	 IRANK(NLAST) = 0
C
C        AT THIS POINT:
C        LIST1 = - (INDEX OF LEAST ELEMENT IN THE FIRST LIST)
C        LIST2 = - (INDEX OF LEAST ELEMENT IN THE SECOND LIST)
C        FOR EACH K, IRANK(K) IS THE INDEX OF THE NEXT ELEMENT IN THE
C        CURRENT LIST, EXCEPT THAT, IF THERE IS NO SUCH ELEMENT,
C        IRANK(K) IS - (INDEX OF THE LEAST ELEMENT IN THE NEXT LIST
C        BUT 1)  OR 0 IF THERE IS NO SUCH LIST.
C
C        START MERGING LISTS BY PAIRS.
C
   60    ILIST = -1
	 I = -LIST1
	 J = -LIST2
   80    K = I
	 IF (RV(I).GT.RV(J)) K = J
	 IF (ILIST.LT.0) THEN
	    LIST1 = -K
	    ILIST = 0
	 ELSE IF (ILIST.EQ.0) THEN
	    LIST2 = -K
	    ILIST = 1
	    NLAST = L
	 ELSE
	    IRANK(NLAST) = -K
	    NLAST = L
	 END IF
C
C        MOVE ALONG THE LISTS UNTIL ONE FINISHES.
C
C        NEW VARIABLES I2, J2 AND K2 ARE USED INSTEAD OF I, J AND K
C        WITHIN THE INNERMOST BLOCK TO ENCOURAGE OPTIMISING COMPILERS TO
C        STORE THEM IN REGISTERS.
C         I2 POINTS TO THE CURRENT ELEMENT IN THE FIRST LIST
C         J2 POINTS TO THE CURRENT ELEMENT IN THE SECOND LIST
C         K2 POINTS TO THE CURRENT ELEMENT IN THE MERGED LIST
C
	 I2 = I
	 J2 = J
	 IF (K.NE.I2) GO TO 140
  100    A = RV(J2)
	 K2 = I2
  120    I2 = K2
	 K2 = IRANK(I2)
	 IF (K2.LE.0) GO TO 180
	 IF (A.GE.RV(K2)) GO TO 120
	 IRANK(I2) = J2
	 I2 = K2
  140    A = RV(I2)
	 K2 = J2
  160    J2 = K2
	 K2 = IRANK(J2)
	 IF (K2.LE.0) GO TO 200
	 IF (A.GT.RV(K2)) GO TO 160
	 IRANK(J2) = I2
	 J2 = K2
	 GO TO 100
C
C        ADD THE REMAINS OF ONE LIST TO THE OTHER.
C
  180    K = 1
	 I1 = K2
	 GO TO 220
  200    K = 2
	 J1 = K2
  220    I = I2
	 J = J2
	 IF (K.EQ.1) THEN
C
C           FIRST LIST IS EXHAUSTED
C
	    IRANK(I) = J
	    I = -I1
	    J1 = J
  240       J = J1
	    J1 = IRANK(J)
	    IF (J1.GT.0) GO TO 240
	    L = J
	    J = -J1
	 ELSE
C
C           SECOND LIST IS EXHAUSTED
C
	    IRANK(J) = I
	    J = -J1
	    I1 = I
  260       I = I1
	    I1 = IRANK(I)
	    IF (I1.GT.0) GO TO 260
	    L = I
	    I = -I1
	 END IF
C
C        TIDY UP AND CARRY ON IF NOT FINISHED.
C
	 IF ((I.NE.0) .AND. (J.NE.0)) GO TO 80
	 IRANK(L) = 0
	 K = I + J
	 IF (ILIST.GT.0) THEN
	    IRANK(NLAST) = -K
	    GO TO 60
	 ELSE IF (K.NE.0) THEN
	    LIST2 = -K
	    GO TO 60
	 END IF
C
C        IF DESCENDING, REVERSE ALL POINTERS BETWEEN EQUALITY
C        BLOCKS.
C
  280    IF ((ORDER.EQ.'D') .OR. (ORDER.EQ.'d')) THEN
	    I = 0
	    J = -LIST1
  300       K = J
	    K1 = K
	    A = RV(K)
  320       K = K1
	    K1 = IRANK(K)
	    IF (K1.NE.0) THEN
	       IF (A.EQ.RV(K1)) GO TO 320
	    END IF
	    IRANK(K) = I
	    I = J
	    J = K1
	    IF (J.NE.0) GO TO 300
	    LIST1 = -I
	 END IF
C
C        CONVERT THE LIST FORM TO RANKS AND RETURN.
C
	 K = M1
	 I = -LIST1
  340    I1 = IRANK(I)
	 IRANK(I) = K
	 K = K + 1
	 I = I1
	 IF (I.GT.0) GO TO 340
C
      END IF
C
      IF (IERR.NE.0) THEN
	 IFAIL = P01ABF(IFAIL,IERR,SRNAME,NREC,P01REC)
      ELSE
	 IFAIL = 0
      END IF
      RETURN
C
99999 FORMAT (' ** On entry, one or more of the following parameter va',
     *  'lues is illegal',/'    M1 =',I16,'  M2 =',I16)
99998 FORMAT (' ** On entry, ORDER has an illegal value: ORDER = ',A1)
      END

C     ===================================================
C     ================= M01EAF ==========================
C     ===================================================

      SUBROUTINE M01EAF(RV,M1,M2,IRANK,IFAIL)
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     M01EAF RE-ARRANGES A VECTOR OF real*8 NUMBERS INTO
C     THE ORDER SPECIFIED BY A VECTOR OF RANKS.
C
C     M01EAF IS DESIGNED TO BE USED TYPICALLY IN CONJUNCTION
C     WITH THE M01D- RANKING ROUTINES. AFTER ONE OF THE M01D-
C     ROUTINES HAS BEEN CALLED TO DETERMINE A VECTOR OF RANKS,
C     M01EAF CAN BE CALLED TO RE-ARRANGE A VECTOR OF real*8
C     NUMBERS INTO THE RANK ORDER. IF THE VECTOR OF RANKS HAS
C     BEEN GENERATED IN SOME OTHER WAY, THEN M01ZBF SHOULD BE
C     CALLED TO CHECK ITS VALIDITY BEFORE M01EAF IS CALLED.
C
C     WRITTEN BY N.M.MACLAREN, UNIVERSITY OF CAMBRIDGE.
C     REVISED BY NAG CENTRAL OFFICE.
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='M01EAF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, M1, M2
C     .. Array Arguments ..
      DOUBLE PRECISION  RV(M2)
      INTEGER           IRANK(M2)
C     .. Local Scalars ..
      DOUBLE PRECISION  A, B
      INTEGER           I, IERR, J, K
C     .. Local Arrays ..
      CHARACTER*80      P01REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Executable Statements ..
C
C       CHECK THE PARAMETERS AND MODIFY IRANK.
C
      IF (M2.LT.1 .OR. M1.LT.1 .OR. M1.GT.M2) THEN
	 IERR = 1
	 WRITE (P01REC,FMT=99999) M1, M2
      ELSE
	 IERR = 0
	 DO 20 I = M1, M2
	    J = IRANK(I)
	    IF ((J.LT.M1) .OR. (J.GT.M2)) GO TO 100
	    IF (I.NE.J) IRANK(I) = -J
   20    CONTINUE
C
C        MOVE EACH NON-TRIVIAL CYCLE ROUND.
C
	 DO 60 I = M1, M2
	    K = -IRANK(I)
	    IF (K.GE.0) THEN
	       J = I
	       A = RV(I)
   40          IRANK(J) = K
	       B = RV(K)
	       RV(K) = A
	       J = K
	       A = B
	       K = -IRANK(J)
	       IF (K.GT.0) GO TO 40
	       IF (J.NE.I) GO TO 120
	    END IF
   60    CONTINUE
      END IF
C
C       RETURN
C
   80 IF (IERR.NE.0) THEN
	 IFAIL = P01ABF(IFAIL,IERR,SRNAME,2,P01REC)
      ELSE
	 IFAIL = 0
      END IF
      RETURN
  100 IERR = 2
      WRITE (P01REC(2),FMT=99997) I, J
      GO TO 140
  120 IERR = 3
      WRITE (P01REC(2),FMT=99996) J
  140 WRITE (P01REC(1),FMT=99998)
C
C     RESTORE IRANK
C
      DO 160 J = M1, M2
	 IRANK(J) = ABS(IRANK(J))
  160 CONTINUE
      GO TO 80
C
99999 FORMAT (' ** On entry, one or more of the following parameter va',
     *  'lues is illegal',/'    M1 =',I16,'  M2 =',I16)
99998 FORMAT (' ** IRANK(M1:M2) does not contain a permutation of the ',
     *  'integers M1 to M2')
99997 FORMAT ('    IRANK(',I6,') contains an out-of-range value',I16)
99996 FORMAT ('    IRANK contains a repeated value',I16)
      END

C     ================================================================
C     ====================P01ABF =====================================
C     ================================================================

      INTEGER FUNCTION P01ABF(IFAIL,IERROR,SRNAME,NREC,REC)
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C     MARK 13 REVISED. IER-621 (APR 1988).
C     MARK 13B REVISED. IER-668 (AUG 1988).
C
C     P01ABF is the error-handling routine for the NAG Library.
C
C     P01ABF either returns the value of IERROR through the routine
C     name (soft failure), or terminates execution of the program
C     (hard failure). Diagnostic messages may be output.
C
C     If IERROR = 0 (successful exit from the calling routine),
C     the value 0 is returned through the routine name, and no
C     message is output
C
C     If IERROR is non-zero (abnormal exit from the calling routine),
C     the action taken depends on the value of IFAIL.
C
C     IFAIL =  1: soft failure, silent exit (i.e. no messages are
C                 output)
C     IFAIL = -1: soft failure, noisy exit (i.e. messages are output)
C     IFAIL =-13: soft failure, noisy exit but standard messages from
C                 P01ABF are suppressed
C     IFAIL =  0: hard failure, noisy exit
C
C     For compatibility with certain routines included before Mark 12
C     P01ABF also allows an alternative specification of IFAIL in which
C     it is regarded as a decimal integer with least significant digits
C     cba. Then
C
C     a = 0: hard failure  a = 1: soft failure
C     b = 0: silent exit   b = 1: noisy exit
C
C     except that hard failure now always implies a noisy exit.
C
C     S.Hammarling, M.P.Hooper and J.J.du Croz, NAG Central Office.
C
C     .. Scalar Arguments ..
      INTEGER                 IERROR, IFAIL, NREC
      CHARACTER*(*)           SRNAME
C     .. Array Arguments ..
      CHARACTER*(*)           REC(*)
C     .. Local Scalars ..
      INTEGER                 I, NERR
      CHARACTER*72            MESS
C     .. External Subroutines ..
      EXTERNAL                P01ABZ, X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC               ABS, MOD
C     .. Executable Statements ..
      IF (IERROR.NE.0) THEN
C        Abnormal exit from calling routine
	 IF (IFAIL.EQ.-1 .OR. IFAIL.EQ.0 .OR. IFAIL.EQ.-13 .OR.
     *       (IFAIL.GT.0 .AND. MOD(IFAIL/10,10).NE.0)) THEN
C           Noisy exit
	    CALL X04AAF(0,NERR)
	    DO 20 I = 1, NREC
	       CALL X04BAF(NERR,REC(I))
   20       CONTINUE
	    IF (IFAIL.NE.-13) THEN
	       WRITE (MESS,FMT=99999) SRNAME, IERROR
	       CALL X04BAF(NERR,MESS)
	       IF (ABS(MOD(IFAIL,10)).NE.1) THEN
C                 Hard failure
		  CALL X04BAF(NERR,
     *                     ' ** NAG hard failure - execution terminated'
     *                        )
		  CALL P01ABZ
	       ELSE
C                 Soft failure
		  CALL X04BAF(NERR,
     *                        ' ** NAG soft failure - control returned')
	       END IF
	    END IF
	 END IF
      END IF
      P01ABF = IERROR
      RETURN
C
99999 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A,': IFAIL',
     *  ' =',I6)
      END

C     ==========================================================
C     ==================== G05CAF ==============================
C     ==========================================================

      DOUBLE PRECISION FUNCTION G05CAF(X)
C     MARK 14 RE-ISSUE. NAG COPYRIGHT 1989.
C
C     Returns a pseudo-random number uniformly distributed between
C     A and B.
C
C     Pseudo-random numbers are generated by the auxiliary routine
C     G05CAY, 63 at a time, and stored in the array RV in common block
C     CG05CA. G05CAF copies one number from the array RV into X,
C     calling G05CAY to replenish RV when necessary.
C
C     This revised version of G05CAF has been introduced for
C     compatibility with the new routines G05FAF, G05FBF and G05FDF,
C     introduced at Mark 14.
C
C     Jeremy Du Croz, NAG Ltd, June 1989.
C
C     .. Parameters ..
      INTEGER                          LV
      PARAMETER                        (LV=63)
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 X
C     .. Scalars in Common ..
      INTEGER                          KV
C     .. Arrays in Common ..
      DOUBLE PRECISION                 RV(LV)
C     .. Local Scalars ..
      LOGICAL                          INIT
C     .. External Subroutines ..
      EXTERNAL                         G05CAY, G05CAZ
C     .. Common blocks ..
      COMMON                           /CG05CA/RV, KV
C     .. Save statement ..
      SAVE                             INIT, /CG05CA/
C     .. Data statements ..
      DATA                             INIT/.TRUE./
C     .. Executable Statements ..
C
C     Ensure that KV in common block /CG05CA/ has been initialized
C
      IF (INIT) CALL G05CAZ(INIT)
C
C     Replenish the buffer if necessary
C
      IF (KV.GE.LV) CALL G05CAY(.FALSE.)
C
      KV = KV + 1
      G05CAF = RV(KV)
      RETURN
      END

C     ==============================================================
C     ====================== d01dam  ===============================
C     ==============================================================

      SUBROUTINE D01DAM(F,A,B,EPSABS,EPSREL,RESULT,ABSERR,WORK,LWORK,
     *                  IWORK,LIWORK,IFAIL)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C
C     D01AJF IS A GENERAL PURPOSE INTEGRATOR WHICH CALCULATES
C     AN APPROXIMATION TO THE INTEGRAL OF A FUNCTION OVER A FINITE
C     INTERVAL (A,B)
C
C     D01AJF ITSELF IS ESSENTIALLY A DUMMY ROUTINE WHOSE FUNCTION IS TO
C     PARTITION THE WORK ARRAYS WORK AND IWORK FOR USE BY D01AJV.
C     WORK IS PARTITIONED INTO 4 ARRAYS EACH OF SIZE LIMIT, WHERE
C     LIMIT = MIN(LWORK/4, LIWORK).
C     IWORK IS A SINGLE ARRAY IN D01AJV OF SIZE LIMIT.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO
      PARAMETER         (ZERO=0.0D0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D01AJF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, ABSERR, B, EPSABS, EPSREL, RESULT
      INTEGER           IFAIL, LIWORK, LWORK
C     .. Array Arguments ..
      DOUBLE PRECISION  WORK(LWORK)
      INTEGER           IWORK(LIWORK)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Local Scalars ..
      INTEGER           I, IBL, IEL, IER, IERR, IRL, J, JBL, JEL, JRL,
     *                  K, LAST, LIMIT, NEVAL, NREC
      CHARACTER*1       ORDER
C     .. Local Arrays ..
      CHARACTER*80      REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          D01AJV, M01DAF, M01EAF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MIN
C     .. Executable Statements ..
      IER = IFAIL
C     CHECK THAT MINIMUM WORKSPACE REQUIREMENTS ARE MET
      IF (LWORK.LT.4 .OR. LIWORK.LT.1) GO TO 100
C     LIMIT - UPPER BOUND ON NUMBER OF SUBINTERVALS
      LIMIT = MIN(LWORK/4,LIWORK)
C     SET UP BASE ADDRESSES FOR WORK ARRAYS
      IBL = LIMIT + 1
      IEL = LIMIT + IBL
      IRL = LIMIT + IEL
C     PERFORM INTEGRATION
      CALL D01AJV(F,A,B,ABS(EPSABS),ABS(EPSREL),WORK(1),WORK(IBL),
     *            WORK(IEL),WORK(IRL),LIMIT,IWORK,LIMIT,RESULT,ABSERR,
     *            NEVAL,IER)
C     RE-ORDER THE ELEMENTS OF WORK SO THAT THE RIGHT END-POINTS OF THE
C     SUB-INTERVALS (BLIST), ABSOLUTE ERROR ESTIMATES (ELIST) AND
C     APPROXIMATIONS TO THE INTEGRAL OVER THE SUB-INTERVALS (RLIST)
C     ARE EASILY ACCESSIBLE TO THE USER (SEE D01AJV).
      LAST = IWORK(1)
      IF (IER.LT.6 .AND. LAST.GE.1) THEN
	 JBL = LAST
	 JEL = 2*LAST
	 JRL = 3*LAST
	 IF (LAST.LT.LIMIT) THEN
	    DO 20 I = 1, LAST
	       WORK(JBL+I) = WORK(IBL+I-1)
   20       CONTINUE
	    DO 40 I = 1, LAST
	       WORK(JEL+I) = WORK(IEL+I-1)
   40       CONTINUE
	    DO 60 I = 1, LAST
	       WORK(JRL+I) = WORK(IRL+I-1)
   60       CONTINUE
	 END IF
C        ZERO THE REMAINING PART OF WORK
	 K = 4*LAST + 1
	 DO 80 J = K, LWORK
	    WORK(J) = ZERO
   80    CONTINUE
C        SORT THE ELEMENTS OF ALIST INTO ASCENDING ORDER USING M01DAF
C        AND M01EAF. ON EXIT FROM M01DAF, IWORK(1), ... ,IWORK(LAST)
C        CONTAIN THE RANKS OF ALIST(1), ... ,ALIST(LAST).
	 IERR = 0
	 ORDER = 'A'
	 CALL M01DAF(WORK(1),1,LAST,ORDER,IWORK,IERR)
	 CALL M01EAF(WORK(1),1,LAST,IWORK,IERR)
C        USE IWORK(1), ... ,IWORK(LAST) TO RECOVER THE VALUES OF
C        BLIST(I), ELIST(I) AND RLIST(I) CORRESPONDING TO ALIST(I)
C        AS RETURNED BY M01EAF, WHERE I = 1, 2, ...,LAST.
	 JBL = JBL + 1
	 CALL M01EAF(WORK(JBL),1,LAST,IWORK,IERR)
	 JEL = JEL + 1
	 CALL M01EAF(WORK(JEL),1,LAST,IWORK,IERR)
	 JRL = JRL + 1
	 CALL M01EAF(WORK(JRL),1,LAST,IWORK,IERR)
	 IWORK(1) = LAST
      END IF
      IF (IER.NE.0) GO TO 120
      IFAIL = 0
      GO TO 140
C     ERROR 6 = INSUFFICIENT WORKSPACE
  100 IER = 6
      WRITE (REC,FMT=99999) LWORK, LIWORK
  120 NREC = 2
      IF (IER.EQ.1) THEN
	 WRITE (REC,FMT=99998) LIMIT, LWORK, LIWORK
      ELSE IF (IER.EQ.2) THEN
	 WRITE (REC,FMT=99997) EPSABS, EPSREL
      ELSE IF (IER.EQ.3) THEN
	 NREC = 0
      ELSE IF (IER.EQ.4) THEN
	 WRITE (REC(1),FMT=99996)
	 NREC = 1
      ELSE IF (IER.EQ.5) THEN
	 WRITE (REC(1),FMT=99995)
	 NREC = 1
      END IF
      IFAIL = P01ABF(IFAIL,IER,SRNAME,NREC,REC)
  140 RETURN
C
99999 FORMAT (' ** On entry, LW.lt.4 or LIW.lt.1:',/'    LW = ',I16,
     *       '  LIW = ',I16)
99998 FORMAT (' ** The maximum number of subdivisions (LIMIT) has been',
     *       ' reached:',/'    LIMIT = ',I16,'   LW = ',I16,'   LIW = ',
     *       I16)
99997 FORMAT (' ** Round-off error prevents the requested tolerance fr',
     *       'om being achieved:',/'    EPSABS = ',1P,D8.1,
     *       '  EPSREL = ',1P,D8.1)
99996 FORMAT (' ** Round-off error is detected in the extrapolation ta',
     *       'ble')
99995 FORMAT (' ** The integral is probably divergent or slowly conver',
     *       'gent')
      END

c    =========================================================
c    ===================== d01ajx ============================
c    =========================================================

      SUBROUTINE D01AJX(LIMIT,LAST,MAXERR,ERMAX,ELIST,IORD,NRMAX)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C     BASED ON QUADPACK ROUTINE  QSORT.
C     ..................................................................
C
C           PURPOSE
C              THIS ROUTINE MAINTAINS THE DESCENDING ORDERING IN THE
C              LIST OF THE LOCAL ERROR ESTIMATES RESULTING FROM THE
C              INTERVAL SUBDIVISION PROCESS. AT EACH CALL TWO ERROR
C              ESTIMATES ARE INSERTED USING THE SEQUENTIAL SEARCH
C              TOP-DOWN FOR THE LARGEST ERROR ESTIMATE AND BOTTOM-UP
C              FOR THE SMALLEST ERROR ESTIMATE.
C
C           PARAMETERS (MEANING AT OUTPUT)
C              LIMIT  - INTEGER
C                       MAXIMUM NUMBER OF ERROR ESTIMATES THE LIST CAN
C                       CONTAIN
C
C              LAST   - INTEGER
C                       NUMBER OF ERROR ESTIMATES CURRENTLY IN THE LIST
C
C              MAXERR - INTEGER
C                       MAXERR POINTS TO THE NRMAX-TH LARGEST ERROR
C                       ESTIMATE CURRENTLY IN THE LIST
C
C              ERMAX  - REAL
C                       NRMAX-TH LARGEST ERROR ESTIMATE
C                       ERMAX = ELIST(MAXERR)
C
C              ELIST  - REAL
C                       VECTOR OF DIMENSION LAST CONTAINING THE ERROR
C                       ESTIMATES
C
C              IORD   - INTEGER
C                       VECTOR OF DIMENSION LAST, THE FIRST K ELEMENTS
C                       OF WHICH CONTAIN POINTERS TO THE ERROR ESTIMATES
C                       SUCH THAT ELIST(IORD(1)),... , ELIST(IORD(K))
C                       FORM A DECREASING SEQUENCE, WITH
C                       K = LAST IF LAST.LE.(LIMIT/2+2), AND
C                       K = LIMIT+1-LAST OTHERWISE
C
C              NRMAX  - INTEGER
C                       MAXERR = IORD(NRMAX)
C
C     ..................................................................
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  ERMAX
      INTEGER           LAST, LIMIT, MAXERR, NRMAX
C     .. Array Arguments ..
      DOUBLE PRECISION  ELIST(LAST)
      INTEGER           IORD(LAST)
C     .. Local Scalars ..
      DOUBLE PRECISION  ERRMAX, ERRMIN
      INTEGER           I, IBEG, IDO, ISUCC, J, JBND, JUPBN, K
C     .. Executable Statements ..
C
C           CHECK WHETHER THE LIST CONTAINS MORE THAN TWO ERROR
C           ESTIMATES.
C
      IF (LAST.GT.2) GO TO 20
      IORD(1) = 1
      IORD(2) = 2
      GO TO 180
C
C           THIS PART OF THE ROUTINE IS ONLY EXECUTED IF, DUE TO A
C           DIFFICULT INTEGRAND, SUBDIVISION INCREASED THE ERROR
C           ESTIMATE. IN THE NORMAL CASE THE INSERT PROCEDURE SHOULD
C           START AFTER THE NRMAX-TH LARGEST ERROR ESTIMATE.
C
   20 ERRMAX = ELIST(MAXERR)
      IF (NRMAX.EQ.1) GO TO 60
      IDO = NRMAX - 1
      DO 40 I = 1, IDO
         ISUCC = IORD(NRMAX-1)
C        ***JUMP OUT OF DO-LOOP
         IF (ERRMAX.LE.ELIST(ISUCC)) GO TO 60
         IORD(NRMAX) = ISUCC
         NRMAX = NRMAX - 1
   40 CONTINUE
C
C           COMPUTE THE NUMBER OF ELEMENTS IN THE LIST TO BE MAINTAINED
C           IN DESCENDING ORDER. THIS NUMBER DEPENDS ON THE NUMBER OF
C           SUBDIVISIONS STILL ALLOWED.
C
   60 JUPBN = LAST
      IF (LAST.GT.(LIMIT/2+2)) JUPBN = LIMIT + 3 - LAST
      ERRMIN = ELIST(LAST)
C
C           INSERT ERRMAX BY TRAVERSING THE LIST TOP-DOWN, STARTING
C           COMPARISON FROM THE ELEMENT ELIST(IORD(NRMAX+1)).
C
      JBND = JUPBN - 1
      IBEG = NRMAX + 1
      IF (IBEG.GT.JBND) GO TO 100
      DO 80 I = IBEG, JBND
         ISUCC = IORD(I)
C        ***JUMP OUT OF DO-LOOP
         IF (ERRMAX.GE.ELIST(ISUCC)) GO TO 120
         IORD(I-1) = ISUCC
   80 CONTINUE
  100 IORD(JBND) = MAXERR
      IORD(JUPBN) = LAST
      GO TO 180
C
C           INSERT ERRMIN BY TRAVERSING THE LIST BOTTOM-UP.
C
  120 IORD(I-1) = MAXERR
      K = JBND
      DO 140 J = I, JBND
         ISUCC = IORD(K)
C        ***JUMP OUT OF DO-LOOP
         IF (ERRMIN.LT.ELIST(ISUCC)) GO TO 160
         IORD(K+1) = ISUCC
         K = K - 1
  140 CONTINUE
      IORD(I) = LAST
      GO TO 180
  160 IORD(K+1) = LAST
C
C           SET MAXERR AND ERMAX.
C
  180 MAXERR = IORD(NRMAX)
      ERMAX = ELIST(MAXERR)
      RETURN
      END


c     ===================================================
c     ==================== P01abz =======================
c     ===================================================
      SUBROUTINE P01ABZ
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C
C     Terminates execution when a hard failure occurs.
C
C     ******************** IMPLEMENTATION NOTE ********************
C     The following STOP statement may be replaced by a call to an
C     implementation-dependent routine to display a message and/or
C     to abort the program.
C     *************************************************************
C     .. Executable Statements ..
      STOP
      END


c     =======================================================
c     =================== G05cay ============================
c     =======================================================

      SUBROUTINE G05CAY(REINIT)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C
C     called by G05CAF, G05FAF, G05FBF or G05FDF when needed, to fill
C     the internal array RV in COMMON block CG05CA with new
C     pseudo-random numbers.
C
C     G05CAY uses a multiplicative congruential algorithm
C
C     N := N * 13**13 modulo 2**59
C
C     where N is a notional variable internal to G05CAY. The value of N
C     is converted to a real number in the range 0.0 to 1.0 by scaling
C     by 2**(-59), with care taken that the result lies strictly
C     between 0.0 and 1.0.
C
C     N is initially set to 123456789*(2**32+1) but can be changed
C     by a call to G05CBF or G05CCF.
C
C     G05CAY generates number 63 at a time, in order to achieve
C     efficiency on vector-processing machines. The first call of
C     G05CAY generates 63 consecutive values of N, N(i), i = 1,...,63.
C     Subsequent calls generate the next set of 63 values of N by
C
C     N(i) := N(i) * (13**13)**63 modulo 2**59, for i = 1,...,63.
C
C     The value 63 is defined as the symbol LV in a parameter statement
C     in each routine which needs it. The particular value 63 was
C     chosen because of special properties of the multiplier
C     (13**13)**63 modulo 2**59, which permit efficient multi-length
C     arithmetic when ILIM = 4 (see below). Only a few values of LV
C     have such properties.
C
C     ******************** ADVICE FOR IMPLEMENTORS *********************
C
C     These notes are intended to guide implementors through the text
C     changes necessary to implement the basic random number generator
C     routines G05CAY, G05CAZ, G05CBF, G05CCF, G05CFZ, G05CGZ. Please
C     follow these guidelines, and consult NAG Central Office if in any
C     doubt or difficulty. Please send a listing of your final text for
C     these routines to Central Office.
C
C     1.  Read "DETAILS-NOTE-1" below.
C         Decide the relevant value of ILIM, say nn, taking account of
C         the suggestion for 'long' integers.
C
C     2.  Activate all lines beginning CAnn.
C
C     3.  Read "DETAILS-NOTE-2" below.
C         Check whether your compiler has the functions ISHFT and IAND
C         (or equivalent functions) and compiles inline code for them.
C
C     4.  If ISHFT and IAND or equivalent functions are available as
C         inline functions, activate all lines beginning CYnn. If
C         necessary, change the function names. Otherwise activate all
C         lines beginning CXnn.
C
C     ******************************************************************
C
C     ************************ DETAILS-NOTE-1 **************************
C
C     The algorithm requires that the values of N and of the multi-
C     plier 13**13 be stored as 59-bit unsigned integers and that
C     the least significant 59 bits of their product be computed. On
C     most machines this can be done much more efficiently in
C     machine code than in Fortran. The Fortran code given here is
C     intended to give guidance on a machine code implementation,
C     and to provide a less efficient implementation as a fall-back.
C
C     The 59-bit integer N is stored as a multiple-length integer in
C     the array B. In fact for convenience the 60-bit integer 2*N is
C     stored. The multiplier 13**13 is stored in the array M.
C     The multiplier (13**13)**63 modulo 2**59 is stored in the array
C     MLV in exactly the same way as the basic multiplier is stored in
C     the array M.
C
C     The number of elements in N and M (ILIM) and the number of bits
C     used in each element of N and M (IBITS) depend on the number
C     of bits (including sign) in an integer variable as follows -
C
C        ILIM     IBITS     number of bits in integer variable
C          4        15                 .ge. 32
C          3        20                 .ge. 41
C          2        30                 .ge. 60
C
C     For greatest efficiency ILIM should be chosen as small as
C     possible.
C
C     N.B. the most significant bits of N are stored in B(I,ILIM),
C     the next most significant bits in B(I,ILIM-1), . . . , and
C     the least significant bits in B(I,1). The multiplier is stored
C     in M(ILIM), M(ILIM-1), . . . , M(1) in the same way.
C
C     Note -
C
C     1) in the above table the value of IBITS is less than half the
C     number of bits in an integer variable. This ensures that the
C     necessary integer products can be formed and summed correctly
C     without integer overflow. However many machines have instruc-
C     tions for forming double-length integer products. A machine
C     code implementation can take advantage of this and allow IBITS
C     to be as large (or almost as large) as the number of bits in
C     an integer variable and ILIM to be correspondingly smaller.
C     This should be much more efficient.
C
C     2) the figures in the rightmost column in the above table are
C     correct for the specific value of the multiplier. They are
C     certainly not correct for arbitrary 60-bit arithmetic.
C
C     3) it may well be advantageous to use 'long' integers, if
C     available, within G05CAY, even if they are not used
C     elsewhere in the library.
C
C     Variant code for the array declarations and data statements
C     is supplied in comments beginning CAnn where the digits nn are
C     the value of ILIM.
C
C     ******************************************************************
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
      INTEGER           ILIM
      PARAMETER         (ILIM=4)
CA03  PARAMETER         (ILIM=3)
CA02  PARAMETER         (ILIM=2)
      DOUBLE PRECISION  ONE, R2
      PARAMETER         (ONE=1.0D0,R2=0.5D0)
      DOUBLE PRECISION  RP1, RP2
      PARAMETER         (RP1=R2**60,RP2=R2**30)
CA03  DOUBLE PRECISION  RP1, RP2
CA03  PARAMETER         (RP1=R2**60,RP2=R2**40)
CA02  DOUBLE PRECISION  RP1
CA02  PARAMETER         (RP1=R2**60)
C     .. Scalar Arguments ..
      LOGICAL           REINIT
C     .. Scalars in Common ..
      INTEGER           DEFOPT, OPTION, POSSOP, KV
C     .. Arrays in Common ..
      DOUBLE PRECISION  RV(LV)
      INTEGER           B(0:LV,ILIM)
C     .. Local Scalars ..
      DOUBLE PRECISION  ONEM
      INTEGER           I, T1, T2, T3, U, V
CX03  INTEGER           I, T1, T2, U, V
CX02  INTEGER           I, T1, U, V
CY04  INTEGER           I, T1, T2, T3, T4
CY03  INTEGER           I, T1, T2, T3
CY02  INTEGER           I, T1, T2
      LOGICAL           INIT
C     .. Local Arrays ..
      INTEGER           M(ILIM), MLV(ILIM)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF
      EXTERNAL          X02AJF
C     .. Intrinsic Functions ..
      INTRINSIC         SIGN
C     .. Common blocks ..
      COMMON            /AG05CA/B, OPTION, POSSOP, DEFOPT
      COMMON            /CG05CA/RV, KV
C     .. Save statement ..
      SAVE              /AG05CA/, /CG05CA/, ONEM, INIT
C     .. Data statements ..
      DATA              INIT / .TRUE. /
      DATA              M /
     *                  17917, 13895, 19930,     8 /
CA03 *                  247293, 485810,    275 /
CA02 *                  455329277,    282074 /
      DATA              MLV /
     *                  85,  3703,  6070,  6822 /
CA03 *                  753749, 972915, 218309 /
CA02 *                  121339989, 223549366 /
C     .. Executable Statements ..
C
C     ************************ DETAILS-NOTE-2 **************************
C
C     It is advantageous to use non-standard Fortran intrinsic
C     functions for shifting and masking if these are available and if
C     they are compiled as in-line code without the overhead of a
C     subroutine call. Alternative code is given which uses the integer
C     functions:
C
C     ISHFT(I,J) to shift I J bits to the left (a negative value of
C                 J indicating a right shift)
C     IAND(I,J)  to form the logical and of I and J
C
C     It may be necesssary to replace these by calls to different
C     intrinsic functions provided by the fortran compiler.
C
C     Variant code for this computation is supplied in comments
C     beginning CXnn (using only arithmetic operations) or in
C     comments beginning CYnn (using shifting and masking functions)
C     where the digits nn are the value of ILIM.
C
C     ******************************************************************
C
      IF (INIT.OR.REINIT) THEN
         INIT = .FALSE.
         ONEM = ONE - X02AJF()
C
C        Generate first buffer of LV integers by multiplying
C        recursively by M modulo 2**59.
C        This loop cannot be vectorized.
C
         DO 20 I = 1, LV
            V = B(I-1,1)*M(1)
            U = V/32768
            B(I,1) = V - 32768*U
            V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
            U = V/32768
            B(I,2) = V - 32768*U
            V = U + B(I-1,3)*M(1) + B(I-1,2)*M(2) + B(I-1,1)*M(3)
            U = V/32768
            B(I,3) = V - 32768*U
            V = U + B(I-1,4)*M(1) + B(I-1,3)*M(2) + B(I-1,2)*M(3)
     *            + B(I-1,1)*M(4)
            U = V/32768
            B(I,4) = V - 32768*U
CX03        V = B(I-1,1)*M(1)
CX03        U = V/1048576
CX03        B(I,1) = V - 1048576*U
CX03        V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CX03        U = V/1048576
CX03        B(I,2) = V - 1048576*U
CX03        V = U + B(I-1,3)*M(1) + B(I-1,2)*M(2) + B(I-1,1)*M(3)
CX03        U = V/1048576
CX03        B(I,3) = V - 1048576*U
CX02        V = B(I-1,1)*M(1)
CX02        U = V/1073741824
CX02        B(I,1) = V - 1073741824*U
CX02        V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CX02        U = V/1073741824
CX02        B(I,2) = V - 1073741824*U
CY04        T1 = B(I-1,1)*M(1)
CY04        T2 = ISHFT(T1,-15) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY04        T3 = ISHFT(T2,-15) + B(I-1,3)*M(1) + B(I-1,2)*M(2)
CY04 *                         + B(I-1,1)*M(3)
CY04        T4 = ISHFT(T3,-15) + B(I-1,4)*M(1) + B(I-1,3)*M(2)
CY04 *                         + B(I-1,2)*M(3) + B(I-1,1)*M(4)
CY04        B(I,4) = IAND(T4,32767)
CY04        B(I,3) = IAND(T3,32767)
CY04        B(I,2) = IAND(T2,32767)
CY04        B(I,1) = IAND(T1,32767)
CY03        T1 = B(I-1,1)*M(1)
CY03        T2 = ISHFT(T1,-20) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY03        T3 = ISHFT(T2,-20) + B(I-1,3)*M(1) + B(I-1,2)*M(2)
CY03 *                         + B(I-1,1)*M(3)
CY03        B(I,3) = IAND(T3,1048575)
CY03        B(I,2) = IAND(T2,1048575)
CY03        B(I,1) = IAND(T1,1048575)
CY02        T1 = B(I-1,1)*M(1)
CY02        T2 = ISHFT(T1,-30) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY02        B(I,2) = IAND(T2,1073741823)
CY02        B(I,1) = IAND(T1,1073741823)
   20    CONTINUE
      ELSE
C
C        Generate next buffer of LV integers by multiplying in
C        parallel by M**LV modulo 2**59.
C
         DO 40 I = 1, LV
            V = B(I,1)*MLV(1)
            U = V/32768
            T1 = V - 32768*U
            V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
            U = V/32768
            T2 = V - 32768*U
            V = U + B(I,3)*MLV(1) + B(I,2)*MLV(2) + B(I,1)*MLV(3)
            U = V/32768
            T3 = V - 32768*U
            V = U + B(I,4)*MLV(1) + B(I,3)*MLV(2) + B(I,2)*MLV(3)
     *            + B(I,1)*MLV(4)
            U = V/32768
            B(I,4) = V - 32768*U
            B(I,3) = T3
            B(I,2) = T2
            B(I,1) = T1
CX03        V = B(I,1)*MLV(1)
CX03        U = V/1048576
CX03        T1 = V - 1048576*U
CX03        V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CX03        U = V/1048576
CX03        T2 = V - 1048576*U
CX03        V = U + B(I,3)*MLV(1) + B(I,2)*MLV(2) + B(I,1)*MLV(3)
CX03        U = V/1048576
CX03        B(I,3) = V - 1048576*U
CX03        B(I,2) = T2
CX03        B(I,1) = T1
CX02        V = B(I,1)*MLV(1)
CX02        U = V/1073741824
CX02        T1 = V - 1073741824*U
CX02        V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CX02        U = V/1073741824
CX02        B(I,2) = V - 1073741824*U
CX02        B(I,1) = T1
CY04        T1 = B(I,1)*MLV(1)
CY04        T2 = ISHFT(T1,-15) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY04        T3 = ISHFT(T2,-15) + B(I,3)*MLV(1) + B(I,2)*MLV(2)
CY04 *                         + B(I,1)*MLV(3)
CY04        T4 = ISHFT(T3,-15) + B(I,4)*MLV(1) + B(I,3)*MLV(2)
CY04 *                         + B(I,2)*MLV(3) + B(I,1)*MLV(4)
CY04        B(I,4) = IAND(T4,32767)
CY04        B(I,3) = IAND(T3,32767)
CY04        B(I,2) = IAND(T2,32767)
CY04        B(I,1) = IAND(T1,32767)
CY03        T1 = B(I,1)*MLV(1)
CY03        T2 = ISHFT(T1,-20) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY03        T3 = ISHFT(T2,-20) + B(I,3)*MLV(1) + B(I,2)*MLV(2)
CY03 *                         + B(I,1)*MLV(3)
CY03        B(I,3) = IAND(T3,1048575)
CY03        B(I,2) = IAND(T2,1048575)
CY03        B(I,1) = IAND(T1,1048575)
CY02        T1 = B(I,1)*MLV(1)
CY02        T2 = ISHFT(T1,-30) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY02        B(I,2) = IAND(T2,1073741823)
CY02        B(I,1) = IAND(T1,1073741823)
   40    CONTINUE
      END IF
C
C     Convert integers in B to real numbers in (0.0,1.0) stored in RV.
C
      DO 60 I = 1, LV
         RV(I) = MIN(ONEM,(B(I,4)*32768+B(I,3))*RP2
     *                     +(B(I,2)*32768+B(I,1))*RP1)
CX03     RV(I) = MIN(ONEM,(B(I,3)*1048576+B(I,2))*RP2 + B(I,1)*RP1)
CX02     RV(I) = MIN(ONEM,(B(I,2)*1073741824+B(I,1))*RP1)
CY04     RV(I) = MIN(ONEM,(ISHFT(B(I,4),15)+B(I,3))*RP2
CY04 *                     +(ISHFT(B(I,2),15)+B(I,1))*RP1)
CY03     RV(I) = MIN(ONEM,(ISHFT(B(I,3),20)+B(I,2))*RP2 + B(I,1)*RP1)
CY02     RV(I) = MIN(ONEM,(ISHFT(B(I,2),30)+B(I,1))*RP1)
   60 CONTINUE
      KV = 0
C
      RETURN
      END

c     ======================================================
c     =================== G05CAZ ===========================
c     ======================================================

      SUBROUTINE G05CAZ(INIT)
C     MARK 14 RE-ISSUE. NAG COPYRIGHT 1989.
C
C     called by G05CAF, G05CBF, G05CCF, G05CFZ, G05CGZ, G05DGF, G05FAF,
C     G05FBF AND G05FDF to ensure that the contents of common blocks
C     /AG05CA/, /BG05CA/, /CG05CA/ and /DG05CA/ are initialized.
C
C     ******************** ADVICE FOR IMPLEMENTORS *********************
C
C     This version of G05CAZ must be used in conjunction with the
C     new auxiliary routine G05CAY which has been introduced at Mark 14.
C
C     These notes are intended to guide implementors through the text
C     changes necessary to implement the basic random number generator
C     routines G05CAY, G05CAZ, G05CBF, G05CCF, G05CFZ, G05CGZ. Please
C     follow these guidelines, and consult NAG Central Office if in any
C     doubt or difficulty. Please send a listing of your final text for
C     these routines to Central Office.
C
C     1.  Prepare code for G05CAY following guidelines supplied there.
C
C     2.  Read "DETAILS-NOTE-1" below.
C
C     3.  Activate all lines beginning CAnn, where nn is the value of
C         ILIM used in G05CAY.
C
C     ******************************************************************
C
C     ************************ DETAILS-NOTE-1 **************************
C
C     G05CAZ must be implemented consistently with G05CAY.
C
C     If G05CAY has been implemented simply by selecting suitable
C     variant code according to the value of ILIM, then a consistent
C     implementation of G05CAY may be obtained by using the variant
C     code supplied in comments beginning CAnn where the digits nn
C     are the value of ILIM.
C
C     If G05CAY has been implemented in machine code, it will still
C     be possible on many machines to implement G05CAZ in Fortran
C     and this will be satisfactory since it is not important for
C     G05CAZ to be particularly efficient. Essentially the code for
C     G05CAZ depends only on how the internal variable N is stored in
C     the array B in the common block /AG05CA/ and the code given
C     below should be applicable provided that N is stored in
C     accordance with a particular value of ILIM as defined in the
C     text of G05CAY.
C
C     ******************************************************************
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
      INTEGER           ILIM
      PARAMETER         (ILIM=4)
CA03  PARAMETER         (ILIM=3)
CA02  PARAMETER         (ILIM=2)
C     .. Scalar Arguments ..
      LOGICAL           INIT
C     .. Scalars in Common ..
      DOUBLE PRECISION  GAMMA, NORMAL, VNORML
      INTEGER           DEFOPT, OPTION, POSSOP
C     .. Arrays in Common ..
      INTEGER           B(0:LV,ILIM)
C     .. Local Scalars ..
      LOGICAL           INIT2
C     .. External Subroutines ..
      EXTERNAL          G05CAY
C     .. Common blocks ..
      COMMON            /AG05CA/B, OPTION, POSSOP, DEFOPT
      COMMON            /BG05CA/NORMAL, GAMMA
      COMMON            /DG05CA/VNORML
C     .. Save statement ..
      SAVE              INIT2, /AG05CA/, /BG05CA/, /DG05CA/
C     .. Data statements ..
      DATA              INIT2/.TRUE./
C     .. Executable Statements ..
C
C     If INIT2 is not already .FALSE. , initialize /AG05CA/, /BG05CA/
C     and /DG05CA/ and set INIT2 to .FALSE.
C
      IF (INIT2) THEN
C
         B(0,1) =  6698
         B(0,2) =  7535
         B(0,3) = 26792
         B(0,4) = 30140
CA03     B(0,1) = 498218
CA03     B(0,2) = 172267
CA03     B(0,3) = 964506
CA02     B(0,1) = 246913578
CA02     B(0,2) = 987654312
         OPTION = 0
         DEFOPT = 0
         POSSOP = 0
C
         NORMAL = 1.0D0
         GAMMA = -1.0D0
         VNORML = 256.0D0
C
         INIT2 = .FALSE.
C
C        Initialize the buffer
C
         CALL G05CAY(.TRUE.)
      END IF
C
C     Set INIT to .FALSE. in any case
C
      INIT = .FALSE.
C
      RETURN
      END




